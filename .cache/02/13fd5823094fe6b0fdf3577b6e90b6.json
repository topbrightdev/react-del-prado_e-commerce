{"id":"../node_modules/postcss-dir-pseudo-class/index.es.mjs","dependencies":[{"name":"/home/jarri/Desktop/lenovo2020/projects-web/eCommerce/template-store1/package.json","includedInParent":true,"mtime":1594655291184},{"name":"/home/jarri/Desktop/lenovo2020/projects-web/eCommerce/template-store1/node_modules/postcss-dir-pseudo-class/package.json","includedInParent":true,"mtime":1594306880458},{"name":"postcss","loc":{"line":1,"column":20},"parent":"/home/jarri/Desktop/lenovo2020/projects-web/eCommerce/template-store1/node_modules/postcss-dir-pseudo-class/index.es.mjs","resolved":"/home/jarri/Desktop/lenovo2020/projects-web/eCommerce/template-store1/node_modules/postcss-dir-pseudo-class/node_modules/postcss/lib/postcss.js"},{"name":"postcss-selector-parser","loc":{"line":2,"column":27},"parent":"/home/jarri/Desktop/lenovo2020/projects-web/eCommerce/template-store1/node_modules/postcss-dir-pseudo-class/index.es.mjs","resolved":"/home/jarri/Desktop/lenovo2020/projects-web/eCommerce/template-store1/node_modules/postcss-selector-parser/dist/index.js"}],"generated":{"js":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar _postcss = _interopRequireDefault(require(\"postcss\"));\n\nvar _postcssSelectorParser = _interopRequireDefault(require(\"postcss-selector-parser\"));\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nvar index = _postcss.default.plugin('postcss-dir-pseudo-class', opts => {\n  const dir = Object(opts).dir;\n  const preserve = Boolean(Object(opts).preserve);\n  return root => {\n    // walk rules using the :dir pseudo-class\n    root.walkRules(/:dir\\([^\\)]*\\)/, rule => {\n      let currentRule = rule; // conditionally preserve the original rule\n\n      if (preserve) {\n        currentRule = rule.cloneBefore();\n      } // update the rule selector\n\n\n      currentRule.selector = (0, _postcssSelectorParser.default)(selectors => {\n        // for each (comma separated) selector\n        selectors.nodes.forEach(selector => {\n          // walk all selector nodes that are :dir pseudo-classes\n          selector.walk(node => {\n            if ('pseudo' === node.type && ':dir' === node.value) {\n              // previous and next selector nodes\n              const prev = node.prev();\n              const next = node.next();\n              const prevIsSpaceCombinator = prev && prev.type && 'combinator' === prev.type && ' ' === prev.value;\n              const nextIsSpaceCombinator = next && next.type && 'combinator' === next.type && ' ' === next.value; // preserve the selector tree\n\n              if (prevIsSpaceCombinator && (nextIsSpaceCombinator || !next)) {\n                node.replaceWith(_postcssSelectorParser.default.universal());\n              } else {\n                node.remove();\n              } // conditionally prepend a combinator before inserting the [dir] attribute\n\n\n              const first = selector.nodes[0];\n              const firstIsSpaceCombinator = first && 'combinator' === first.type && ' ' === first.value;\n              const firstIsHtml = first && 'tag' === first.type && 'html' === first.value;\n              const firstIsRoot = first && 'pseudo' === first.type && ':root' === first.value;\n\n              if (first && !firstIsHtml && !firstIsRoot && !firstIsSpaceCombinator) {\n                selector.prepend(_postcssSelectorParser.default.combinator({\n                  value: ' '\n                }));\n              } // value of the :dir pseudo-class\n\n\n              const value = node.nodes.toString(); // whether :dir matches the presumed direction\n\n              const isdir = dir === value; // [dir] attribute\n\n              const dirAttr = _postcssSelectorParser.default.attribute({\n                attribute: 'dir',\n                operator: '=',\n                quoteMark: '\"',\n                value: \"\\\"\".concat(value, \"\\\"\")\n              }); // not[dir] attribute\n\n\n              const notDirAttr = _postcssSelectorParser.default.pseudo({\n                value: \"\".concat(firstIsHtml || firstIsRoot ? '' : 'html', \":not\")\n              });\n\n              notDirAttr.append(_postcssSelectorParser.default.attribute({\n                attribute: 'dir',\n                operator: '=',\n                quoteMark: '\"',\n                value: \"\\\"\".concat('ltr' === value ? 'rtl' : 'ltr', \"\\\"\")\n              }));\n\n              if (isdir) {\n                // if the direction is presumed\n                if (firstIsHtml) {\n                  // insert :root after html tag\n                  selector.insertAfter(first, notDirAttr);\n                } else {\n                  // prepend :root\n                  selector.prepend(notDirAttr);\n                }\n              } else if (firstIsHtml) {\n                // otherwise, insert dir attribute after html tag\n                selector.insertAfter(first, dirAttr);\n              } else {\n                // otherwise, prepend the dir attribute\n                selector.prepend(dirAttr);\n              }\n            }\n          });\n        });\n      }).processSync(currentRule.selector);\n    });\n  };\n});\n\nvar _default = index;\nexports.default = _default;"},"sourceMaps":null,"error":null,"hash":"6781470592d56048a9a0baa8601f9771","cacheData":{"env":{}}}