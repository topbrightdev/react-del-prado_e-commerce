{"id":"../node_modules/postcss-nesting/index.cjs.js","dependencies":[{"name":"/home/jarri/Desktop/lenovo2020/projects-web/eCommerce/template-store1/package.json","includedInParent":true,"mtime":1594655291184},{"name":"/home/jarri/Desktop/lenovo2020/projects-web/eCommerce/template-store1/node_modules/postcss-nesting/package.json","includedInParent":true,"mtime":1594570879066},{"name":"postcss","loc":{"line":5,"column":22},"parent":"/home/jarri/Desktop/lenovo2020/projects-web/eCommerce/template-store1/node_modules/postcss-nesting/index.cjs.js","resolved":"/home/jarri/Desktop/lenovo2020/projects-web/eCommerce/template-store1/node_modules/postcss-nesting/node_modules/postcss/lib/postcss.js"}],"generated":{"js":"'use strict';\n\nfunction _interopDefault(ex) {\n  return ex && typeof ex === 'object' && 'default' in ex ? ex['default'] : ex;\n}\n\nvar postcss = require('postcss');\n\nvar postcss__default = _interopDefault(postcss);\n\nfunction shiftNodesBeforeParent(node) {\n  var parent = node.parent;\n  var index = parent.index(node); // conditionally move previous siblings into a clone of the parent\n\n  if (index) {\n    parent.cloneBefore().removeAll().append(parent.nodes.slice(0, index));\n  } // move the current node before the parent (and after the conditional clone)\n\n\n  parent.before(node);\n  return parent;\n}\n\nfunction cleanupParent(parent) {\n  if (!parent.nodes.length) {\n    parent.remove();\n  }\n} // a valid selector is an ampersand followed by a non-word character or nothing\n\n\nvar validSelector = /&(?:[^\\w-|]|$)/;\nvar replaceable = /&/g;\n\nfunction mergeSelectors(fromSelectors, toSelectors) {\n  return fromSelectors.reduce(function (selectors, fromSelector) {\n    return selectors.concat(toSelectors.map(function (toSelector) {\n      return toSelector.replace(replaceable, fromSelector);\n    }));\n  }, []);\n}\n\nfunction transformRuleWithinRule(node) {\n  // move previous siblings and the node to before the parent\n  var parent = shiftNodesBeforeParent(node); // update the selectors of the node to be merged with the parent\n\n  node.selectors = mergeSelectors(parent.selectors, node.selectors); // conditionally cleanup an empty parent rule\n\n  cleanupParent(parent);\n}\n\nvar isRuleWithinRule = function (node) {\n  return node.type === 'rule' && Object(node.parent).type === 'rule' && node.selectors.every(function (selector) {\n    return selector.trim().lastIndexOf('&') === 0 && validSelector.test(selector);\n  });\n};\n\nvar comma = postcss.list.comma;\n\nfunction transformNestRuleWithinRule(node) {\n  // move previous siblings and the node to before the parent\n  var parent = shiftNodesBeforeParent(node); // clone the parent as a new rule with children appended to it\n\n  var rule = parent.clone().removeAll().append(node.nodes); // replace the node with the new rule\n\n  node.replaceWith(rule); // update the selectors of the node to be merged with the parent\n\n  rule.selectors = mergeSelectors(parent.selectors, comma(node.params)); // conditionally cleanup an empty parent rule\n\n  cleanupParent(parent); // walk the children of the new rule\n\n  walk(rule);\n}\n\nvar isNestRuleWithinRule = function (node) {\n  return node.type === 'atrule' && node.name === 'nest' && Object(node.parent).type === 'rule' && comma(node.params).every(function (selector) {\n    return selector.split('&').length === 2 && validSelector.test(selector);\n  });\n};\n\nvar validAtrules = ['document', 'media', 'supports'];\n/*\n * DEPRECATED: In v7.0.0 these features will be removed as they are not part of\n * the nesting proposal.\n */\n\nfunction atruleWithinRule(node) {\n  // move previous siblings and the node to before the parent\n  var parent = shiftNodesBeforeParent(node); // clone the parent as a new rule with children appended to it\n\n  var rule = parent.clone().removeAll().append(node.nodes); // append the new rule to the node\n\n  node.append(rule); // conditionally cleanup an empty parent rule\n\n  cleanupParent(parent); // walk the children of the new rule\n\n  walk(rule);\n}\n\nvar isAtruleWithinRule = function (node) {\n  return node.type === 'atrule' && validAtrules.indexOf(node.name) !== -1 && Object(node.parent).type === 'rule';\n};\n\nvar comma$1 = postcss.list.comma;\n\nfunction mergeParams(fromParams, toParams) {\n  return comma$1(fromParams).map(function (params1) {\n    return comma$1(toParams).map(function (params2) {\n      return \"\".concat(params1, \" and \").concat(params2);\n    }).join(', ');\n  }).join(', ');\n}\n/*\n * DEPRECATED: In v7.0.0 these features will be removed as they are not part of\n * the nesting proposal.\n */\n\n\nfunction transformAtruleWithinAtrule(node) {\n  // move previous siblings and the node to before the parent\n  var parent = shiftNodesBeforeParent(node); // update the params of the node to be merged with the parent\n\n  node.params = mergeParams(parent.params, node.params); // conditionally cleanup an empty parent rule\n\n  cleanupParent(parent);\n}\n\nvar isAtruleWithinAtrule = function (node) {\n  return node.type === 'atrule' && validAtrules.indexOf(node.name) !== -1 && Object(node.parent).type === 'atrule' && node.name === node.parent.name;\n};\n\nfunction walk(node) {\n  node.nodes.slice(0).forEach(function (child) {\n    if (child.parent === node) {\n      if (isRuleWithinRule(child)) {\n        transformRuleWithinRule(child);\n      } else if (isNestRuleWithinRule(child)) {\n        transformNestRuleWithinRule(child);\n      } else if (isAtruleWithinRule(child)) {\n        atruleWithinRule(child);\n      } else if (isAtruleWithinAtrule(child)) {\n        transformAtruleWithinAtrule(child);\n      }\n\n      if (Object(child.nodes).length) {\n        walk(child);\n      }\n    }\n  });\n}\n\nvar index = postcss__default.plugin('postcss-nesting', function () {\n  return walk;\n});\nmodule.exports = index;"},"sourceMaps":null,"error":null,"hash":"1a7d211ed5b8bc8875cd2b451b438f7a","cacheData":{"env":{}}}