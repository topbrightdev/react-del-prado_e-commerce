{"id":"../node_modules/spdy-transport/lib/spdy-transport/connection.js","dependencies":[{"name":"/home/jarri/Desktop/lenovo2020/projects-web/eCommerce/template-store1/package.json","includedInParent":true,"mtime":1594655165833},{"name":"/home/jarri/Desktop/lenovo2020/projects-web/eCommerce/template-store1/node_modules/spdy-transport/package.json","includedInParent":true,"mtime":1594570878662},{"name":"util","loc":{"line":3,"column":19},"parent":"/home/jarri/Desktop/lenovo2020/projects-web/eCommerce/template-store1/node_modules/spdy-transport/lib/spdy-transport/connection.js","resolved":"/home/jarri/Desktop/lenovo2020/projects-web/eCommerce/template-store1/node_modules/util/util.js"},{"name":"../spdy-transport","loc":{"line":4,"column":24},"parent":"/home/jarri/Desktop/lenovo2020/projects-web/eCommerce/template-store1/node_modules/spdy-transport/lib/spdy-transport/connection.js","resolved":"/home/jarri/Desktop/lenovo2020/projects-web/eCommerce/template-store1/node_modules/spdy-transport/lib/spdy-transport.js"},{"name":"safe-buffer","loc":{"line":5,"column":21},"parent":"/home/jarri/Desktop/lenovo2020/projects-web/eCommerce/template-store1/node_modules/spdy-transport/lib/spdy-transport/connection.js","resolved":"/home/jarri/Desktop/lenovo2020/projects-web/eCommerce/template-store1/node_modules/safe-buffer/index.js"},{"name":"debug","loc":{"line":9,"column":18},"parent":"/home/jarri/Desktop/lenovo2020/projects-web/eCommerce/template-store1/node_modules/spdy-transport/lib/spdy-transport/connection.js","resolved":"/home/jarri/Desktop/lenovo2020/projects-web/eCommerce/template-store1/node_modules/spdy-transport/node_modules/debug/src/browser.js"},{"name":"events","loc":{"line":11,"column":27},"parent":"/home/jarri/Desktop/lenovo2020/projects-web/eCommerce/template-store1/node_modules/spdy-transport/lib/spdy-transport/connection.js","resolved":"/home/jarri/Desktop/lenovo2020/projects-web/eCommerce/template-store1/node_modules/events/events.js"},{"name":"process","parent":"/home/jarri/Desktop/lenovo2020/projects-web/eCommerce/template-store1/node_modules/spdy-transport/lib/spdy-transport/connection.js","resolved":"/home/jarri/Desktop/lenovo2020/projects-web/eCommerce/template-store1/node_modules/process/browser.js"}],"generated":{"js":"\nvar process = require(\"process\");\n'use strict'\n\nvar util = require('util')\nvar transport = require('../spdy-transport')\nvar Buffer = require('safe-buffer').Buffer\n\nvar debug = {\n  server: require('debug')('spdy:connection:server'),\n  client: require('debug')('spdy:connection:client')\n}\nvar EventEmitter = require('events').EventEmitter\n\nvar Stream = transport.Stream\n\nfunction Connection (socket, options) {\n  EventEmitter.call(this)\n\n  var state = {}\n  this._spdyState = state\n\n  // NOTE: There's a big trick here. Connection is used as a `this` argument\n  // to the wrapped `connection` event listener.\n  // socket end doesn't necessarly mean connection drop\n  this.httpAllowHalfOpen = true\n\n  state.timeout = new transport.utils.Timeout(this)\n\n  // Protocol info\n  state.protocol = transport.protocol[options.protocol]\n  state.version = null\n  state.constants = state.protocol.constants\n  state.pair = null\n  state.isServer = options.isServer\n\n  // Root of priority tree (i.e. stream id = 0)\n  state.priorityRoot = new transport.Priority({\n    defaultWeight: state.constants.DEFAULT_WEIGHT,\n    maxCount: transport.protocol.base.constants.MAX_PRIORITY_STREAMS\n  })\n\n  // Defaults\n  state.maxStreams = options.maxStreams ||\n                     state.constants.MAX_CONCURRENT_STREAMS\n\n  state.autoSpdy31 = options.protocol.name !== 'h2' && options.autoSpdy31\n  state.acceptPush = options.acceptPush === undefined\n    ? !state.isServer\n    : options.acceptPush\n\n  if (options.maxChunk === false) { state.maxChunk = Infinity } else if (options.maxChunk === undefined) { state.maxChunk = transport.protocol.base.constants.DEFAULT_MAX_CHUNK } else {\n    state.maxChunk = options.maxChunk\n  }\n\n  // Connection-level flow control\n  var windowSize = options.windowSize || 1 << 20\n  state.window = new transport.Window({\n    id: 0,\n    isServer: state.isServer,\n    recv: {\n      size: state.constants.DEFAULT_WINDOW,\n      max: state.constants.MAX_INITIAL_WINDOW_SIZE\n    },\n    send: {\n      size: state.constants.DEFAULT_WINDOW,\n      max: state.constants.MAX_INITIAL_WINDOW_SIZE\n    }\n  })\n\n  // It starts with DEFAULT_WINDOW, update must be sent to change it on client\n  state.window.recv.setMax(windowSize)\n\n  // Boilerplate for Stream constructor\n  state.streamWindow = new transport.Window({\n    id: -1,\n    isServer: state.isServer,\n    recv: {\n      size: windowSize,\n      max: state.constants.MAX_INITIAL_WINDOW_SIZE\n    },\n    send: {\n      size: state.constants.DEFAULT_WINDOW,\n      max: state.constants.MAX_INITIAL_WINDOW_SIZE\n    }\n  })\n\n  // Various state info\n  state.pool = state.protocol.compressionPool.create(options.headerCompression)\n  state.counters = {\n    push: 0,\n    stream: 0\n  }\n\n  // Init streams list\n  state.stream = {\n    map: {},\n    count: 0,\n    nextId: state.isServer ? 2 : 1,\n    lastId: {\n      both: 0,\n      received: 0\n    }\n  }\n  state.ping = {\n    nextId: state.isServer ? 2 : 1,\n    map: {}\n  }\n  state.goaway = false\n\n  // Debug\n  state.debug = state.isServer ? debug.server : debug.client\n\n  // X-Forwarded feature\n  state.xForward = null\n\n  // Create parser and hole for framer\n  state.parser = state.protocol.parser.create({\n    // NOTE: needed to distinguish ping from ping ACK in SPDY\n    isServer: state.isServer,\n    window: state.window\n  })\n  state.framer = state.protocol.framer.create({\n    window: state.window,\n    timeout: state.timeout\n  })\n\n  // SPDY has PUSH enabled on servers\n  if (state.protocol.name === 'spdy') {\n    state.framer.enablePush(state.isServer)\n  }\n\n  if (!state.isServer) { state.parser.skipPreface() }\n\n  this.socket = socket\n\n  this._init()\n}\nutil.inherits(Connection, EventEmitter)\nexports.Connection = Connection\n\nConnection.create = function create (socket, options) {\n  return new Connection(socket, options)\n}\n\nConnection.prototype._init = function init () {\n  var self = this\n  var state = this._spdyState\n  var pool = state.pool\n\n  // Initialize session window\n  state.window.recv.on('drain', function () {\n    self._onSessionWindowDrain()\n  })\n\n  // Initialize parser\n  state.parser.on('data', function (frame) {\n    self._handleFrame(frame)\n  })\n  state.parser.once('version', function (version) {\n    self._onVersion(version)\n  })\n\n  // Propagate parser errors\n  state.parser.on('error', function (err) {\n    self._onParserError(err)\n  })\n\n  // Propagate framer errors\n  state.framer.on('error', function (err) {\n    self.emit('error', err)\n  })\n\n  this.socket.pipe(state.parser)\n  state.framer.pipe(this.socket)\n\n  // Allow high-level api to catch socket errors\n  this.socket.on('error', function onSocketError (e) {\n    self.emit('error', e)\n  })\n\n  this.socket.once('close', function onclose () {\n    var err = new Error('socket hang up')\n    err.code = 'ECONNRESET'\n    self.destroyStreams(err)\n    self.emit('close', err)\n\n    if (state.pair) {\n      pool.put(state.pair)\n    }\n\n    state.framer.resume()\n  })\n\n  // Reset timeout on close\n  this.once('close', function () {\n    self.setTimeout(0)\n  })\n\n  function _onWindowOverflow () {\n    self._onWindowOverflow()\n  }\n\n  state.window.recv.on('overflow', _onWindowOverflow)\n  state.window.send.on('overflow', _onWindowOverflow)\n\n  // Do not allow half-open connections\n  this.socket.allowHalfOpen = false\n}\n\nConnection.prototype._onVersion = function _onVersion (version) {\n  var state = this._spdyState\n  var prev = state.version\n  var parser = state.parser\n  var framer = state.framer\n  var pool = state.pool\n\n  state.version = version\n  state.debug('id=0 version=%d', version)\n\n  // Ignore transition to 3.1\n  if (!prev) {\n    state.pair = pool.get(version)\n    parser.setCompression(state.pair)\n    framer.setCompression(state.pair)\n  }\n  framer.setVersion(version)\n\n  if (!state.isServer) {\n    framer.prefaceFrame()\n    if (state.xForward !== null) {\n      framer.xForwardedFor({ host: state.xForward })\n    }\n  }\n\n  // Send preface+settings frame (once)\n  framer.settingsFrame({\n    max_header_list_size: state.constants.DEFAULT_MAX_HEADER_LIST_SIZE,\n    max_concurrent_streams: state.maxStreams,\n    enable_push: state.acceptPush ? 1 : 0,\n    initial_window_size: state.window.recv.max\n  })\n\n  // Update session window\n  if (state.version >= 3.1 || (state.isServer && state.autoSpdy31)) { this._onSessionWindowDrain() }\n\n  this.emit('version', version)\n}\n\nConnection.prototype._onParserError = function _onParserError (err) {\n  var state = this._spdyState\n\n  // Prevent further errors\n  state.parser.kill()\n\n  // Send GOAWAY\n  if (err instanceof transport.protocol.base.utils.ProtocolError) {\n    this._goaway({\n      lastId: state.stream.lastId.both,\n      code: err.code,\n      extra: err.message,\n      send: true\n    })\n  }\n\n  this.emit('error', err)\n}\n\nConnection.prototype._handleFrame = function _handleFrame (frame) {\n  var state = this._spdyState\n\n  state.debug('id=0 frame', frame)\n  state.timeout.reset()\n\n  // For testing purposes\n  this.emit('frame', frame)\n\n  var stream\n\n  // Session window update\n  if (frame.type === 'WINDOW_UPDATE' && frame.id === 0) {\n    if (state.version < 3.1 && state.autoSpdy31) {\n      state.debug('id=0 switch version to 3.1')\n      state.version = 3.1\n      this.emit('version', 3.1)\n    }\n    state.window.send.update(frame.delta)\n    return\n  }\n\n  if (state.isServer && frame.type === 'PUSH_PROMISE') {\n    state.debug('id=0 server PUSH_PROMISE')\n    this._goaway({\n      lastId: state.stream.lastId.both,\n      code: 'PROTOCOL_ERROR',\n      send: true\n    })\n    return\n  }\n\n  if (!stream && frame.id !== undefined) {\n    // Load created one\n    stream = state.stream.map[frame.id]\n\n    // Fail if not found\n    if (!stream &&\n        frame.type !== 'HEADERS' &&\n        frame.type !== 'PRIORITY' &&\n        frame.type !== 'RST') {\n      // Other side should destroy the stream upon receiving GOAWAY\n      if (this._isGoaway(frame.id)) { return }\n\n      state.debug('id=0 stream=%d not found', frame.id)\n      state.framer.rstFrame({ id: frame.id, code: 'INVALID_STREAM' })\n      return\n    }\n  }\n\n  // Create new stream\n  if (!stream && frame.type === 'HEADERS') {\n    this._handleHeaders(frame)\n    return\n  }\n\n  if (stream) {\n    stream._handleFrame(frame)\n  } else if (frame.type === 'SETTINGS') {\n    this._handleSettings(frame.settings)\n  } else if (frame.type === 'ACK_SETTINGS') {\n    // TODO(indutny): handle it one day\n  } else if (frame.type === 'PING') {\n    this._handlePing(frame)\n  } else if (frame.type === 'GOAWAY') {\n    this._handleGoaway(frame)\n  } else if (frame.type === 'X_FORWARDED_FOR') {\n    // Set X-Forwarded-For only once\n    if (state.xForward === null) {\n      state.xForward = frame.host\n    }\n  } else if (frame.type === 'PRIORITY') {\n    // TODO(indutny): handle this\n  } else {\n    state.debug('id=0 unknown frame type: %s', frame.type)\n  }\n}\n\nConnection.prototype._onWindowOverflow = function _onWindowOverflow () {\n  var state = this._spdyState\n  state.debug('id=0 window overflow')\n  this._goaway({\n    lastId: state.stream.lastId.both,\n    code: 'FLOW_CONTROL_ERROR',\n    send: true\n  })\n}\n\nConnection.prototype._isGoaway = function _isGoaway (id) {\n  var state = this._spdyState\n  if (state.goaway !== false && state.goaway < id) { return true }\n  return false\n}\n\nConnection.prototype._getId = function _getId () {\n  var state = this._spdyState\n\n  var id = state.stream.nextId\n  state.stream.nextId += 2\n  return id\n}\n\nConnection.prototype._createStream = function _createStream (uri) {\n  var state = this._spdyState\n  var id = uri.id\n  if (id === undefined) { id = this._getId() }\n\n  var isGoaway = this._isGoaway(id)\n\n  if (uri.push && !state.acceptPush) {\n    state.debug('id=0 push disabled promisedId=%d', id)\n\n    // Fatal error\n    this._goaway({\n      lastId: state.stream.lastId.both,\n      code: 'PROTOCOL_ERROR',\n      send: true\n    })\n    isGoaway = true\n  }\n\n  var stream = new Stream(this, {\n    id: id,\n    request: uri.request !== false,\n    method: uri.method,\n    path: uri.path,\n    host: uri.host,\n    priority: uri.priority,\n    headers: uri.headers,\n    parent: uri.parent,\n    readable: !isGoaway && uri.readable,\n    writable: !isGoaway && uri.writable\n  })\n  var self = this\n\n  // Just an empty stream for API consistency\n  if (isGoaway) {\n    return stream\n  }\n\n  state.stream.lastId.both = Math.max(state.stream.lastId.both, id)\n\n  state.debug('id=0 add stream=%d', stream.id)\n  state.stream.map[stream.id] = stream\n  state.stream.count++\n  state.counters.stream++\n  if (stream.parent !== null) {\n    state.counters.push++\n  }\n\n  stream.once('close', function () {\n    self._removeStream(stream)\n  })\n\n  return stream\n}\n\nConnection.prototype._handleHeaders = function _handleHeaders (frame) {\n  var state = this._spdyState\n\n  // Must be HEADERS frame after stream close\n  if (frame.id <= state.stream.lastId.received) { return }\n\n  // Someone is using our ids!\n  if ((frame.id + state.stream.nextId) % 2 === 0) {\n    state.framer.rstFrame({ id: frame.id, code: 'PROTOCOL_ERROR' })\n    return\n  }\n\n  var stream = this._createStream({\n    id: frame.id,\n    request: false,\n    method: frame.headers[':method'],\n    path: frame.headers[':path'],\n    host: frame.headers[':authority'],\n    priority: frame.priority,\n    headers: frame.headers,\n    writable: frame.writable\n  })\n\n  // GOAWAY\n  if (this._isGoaway(stream.id)) {\n    return\n  }\n\n  state.stream.lastId.received = Math.max(state.stream.lastId.received,\n                                          stream.id)\n\n  // TODO(indutny) handle stream limit\n  if (!this.emit('stream', stream)) {\n    // No listeners was set - abort the stream\n    stream.abort()\n    return\n  }\n\n  // Create fake frame to simulate end of the data\n  if (frame.fin) {\n    stream._handleFrame({ type: 'FIN', fin: true })\n  }\n\n  return stream\n}\n\nConnection.prototype._onSessionWindowDrain = function _onSessionWindowDrain () {\n  var state = this._spdyState\n  if (state.version < 3.1 && !(state.isServer && state.autoSpdy31)) {\n    return\n  }\n\n  var delta = state.window.recv.getDelta()\n  if (delta === 0) {\n    return\n  }\n\n  state.debug('id=0 session window drain, update by %d', delta)\n\n  state.framer.windowUpdateFrame({\n    id: 0,\n    delta: delta\n  })\n  state.window.recv.update(delta)\n}\n\nConnection.prototype.start = function start (version) {\n  this._spdyState.parser.setVersion(version)\n}\n\n// Mostly for testing\nConnection.prototype.getVersion = function getVersion () {\n  return this._spdyState.version\n}\n\nConnection.prototype._handleSettings = function _handleSettings (settings) {\n  var state = this._spdyState\n\n  state.framer.ackSettingsFrame()\n\n  this._setDefaultWindow(settings)\n  if (settings.max_frame_size) { state.framer.setMaxFrameSize(settings.max_frame_size) }\n\n  // TODO(indutny): handle max_header_list_size\n  if (settings.header_table_size) {\n    try {\n      state.pair.compress.updateTableSize(settings.header_table_size)\n    } catch (e) {\n      this._goaway({\n        lastId: 0,\n        code: 'PROTOCOL_ERROR',\n        send: true\n      })\n      return\n    }\n  }\n\n  // HTTP2 clients needs to enable PUSH streams explicitly\n  if (state.protocol.name !== 'spdy') {\n    if (settings.enable_push === undefined) {\n      state.framer.enablePush(state.isServer)\n    } else {\n      state.framer.enablePush(settings.enable_push === 1)\n    }\n  }\n\n  // TODO(indutny): handle max_concurrent_streams\n}\n\nConnection.prototype._setDefaultWindow = function _setDefaultWindow (settings) {\n  if (settings.initial_window_size === undefined) {\n    return\n  }\n\n  var state = this._spdyState\n\n  // Update defaults\n  var window = state.streamWindow\n  window.send.setMax(settings.initial_window_size)\n\n  // Update existing streams\n  Object.keys(state.stream.map).forEach(function (id) {\n    var stream = state.stream.map[id]\n    var window = stream._spdyState.window\n\n    window.send.updateMax(settings.initial_window_size)\n  })\n}\n\nConnection.prototype._handlePing = function handlePing (frame) {\n  var self = this\n  var state = this._spdyState\n\n  // Handle incoming PING\n  if (!frame.ack) {\n    state.framer.pingFrame({\n      opaque: frame.opaque,\n      ack: true\n    })\n\n    self.emit('ping', frame.opaque)\n    return\n  }\n\n  // Handle reply PING\n  var hex = frame.opaque.toString('hex')\n  if (!state.ping.map[hex]) {\n    return\n  }\n  var ping = state.ping.map[hex]\n  delete state.ping.map[hex]\n\n  if (ping.cb) {\n    ping.cb(null)\n  }\n}\n\nConnection.prototype._handleGoaway = function handleGoaway (frame) {\n  this._goaway({\n    lastId: frame.lastId,\n    code: frame.code,\n    send: false\n  })\n}\n\nConnection.prototype.ping = function ping (callback) {\n  var state = this._spdyState\n\n  // HTTP2 is using 8-byte opaque\n  var opaque = Buffer.alloc(state.constants.PING_OPAQUE_SIZE)\n  opaque.fill(0)\n  opaque.writeUInt32BE(state.ping.nextId, opaque.length - 4)\n  state.ping.nextId += 2\n\n  state.ping.map[opaque.toString('hex')] = { cb: callback }\n  state.framer.pingFrame({\n    opaque: opaque,\n    ack: false\n  })\n}\n\nConnection.prototype.getCounter = function getCounter (name) {\n  return this._spdyState.counters[name]\n}\n\nConnection.prototype.reserveStream = function reserveStream (uri, callback) {\n  var stream = this._createStream(uri)\n\n  // GOAWAY\n  if (this._isGoaway(stream.id)) {\n    var err = new Error('Can\\'t send request after GOAWAY')\n    process.nextTick(function () {\n      if (callback) { callback(err) } else {\n        stream.emit('error', err)\n      }\n    })\n    return stream\n  }\n\n  if (callback) {\n    process.nextTick(function () {\n      callback(null, stream)\n    })\n  }\n\n  return stream\n}\n\nConnection.prototype.request = function request (uri, callback) {\n  var stream = this.reserveStream(uri, function (err) {\n    if (err) {\n      if (callback) {\n        callback(err)\n      } else {\n        stream.emit('error', err)\n      }\n      return\n    }\n\n    if (stream._wasSent()) {\n      if (callback) {\n        callback(null, stream)\n      }\n      return\n    }\n\n    stream.send(function (err) {\n      if (err) {\n        if (callback) { return callback(err) } else { return stream.emit('error', err) }\n      }\n\n      if (callback) {\n        callback(null, stream)\n      }\n    })\n  })\n\n  return stream\n}\n\nConnection.prototype._removeStream = function _removeStream (stream) {\n  var state = this._spdyState\n\n  state.debug('id=0 remove stream=%d', stream.id)\n  delete state.stream.map[stream.id]\n  state.stream.count--\n\n  if (state.stream.count === 0) {\n    this.emit('_streamDrain')\n  }\n}\n\nConnection.prototype._goaway = function _goaway (params) {\n  var state = this._spdyState\n  var self = this\n\n  state.goaway = params.lastId\n  state.debug('id=0 goaway from=%d', state.goaway)\n\n  Object.keys(state.stream.map).forEach(function (id) {\n    var stream = state.stream.map[id]\n\n    // Abort every stream started after GOAWAY\n    if (stream.id <= params.lastId) {\n      return\n    }\n\n    stream.abort()\n    stream.emit('error', new Error('New stream after GOAWAY'))\n  })\n\n  function finish () {\n    // Destroy socket if there are no streams\n    if (state.stream.count === 0 || params.code !== 'OK') {\n      // No further frames should be processed\n      state.parser.kill()\n\n      process.nextTick(function () {\n        var err = new Error('Fatal error: ' + params.code)\n        self._onStreamDrain(err)\n      })\n      return\n    }\n\n    self.on('_streamDrain', self._onStreamDrain)\n  }\n\n  if (params.send) {\n    // Make sure that GOAWAY frame is sent before dumping framer\n    state.framer.goawayFrame({\n      lastId: params.lastId,\n      code: params.code,\n      extra: params.extra\n    }, finish)\n  } else {\n    finish()\n  }\n}\n\nConnection.prototype._onStreamDrain = function _onStreamDrain (error) {\n  var state = this._spdyState\n\n  state.debug('id=0 _onStreamDrain')\n\n  state.framer.dump()\n  state.framer.unpipe(this.socket)\n  state.framer.resume()\n\n  if (this.socket.destroySoon) {\n    this.socket.destroySoon()\n  }\n  this.emit('close', error)\n}\n\nConnection.prototype.end = function end (callback) {\n  var state = this._spdyState\n\n  if (callback) {\n    this.once('close', callback)\n  }\n  this._goaway({\n    lastId: state.stream.lastId.both,\n    code: 'OK',\n    send: true\n  })\n}\n\nConnection.prototype.destroyStreams = function destroyStreams (err) {\n  var state = this._spdyState\n  Object.keys(state.stream.map).forEach(function (id) {\n    var stream = state.stream.map[id]\n\n    stream.abort()\n    stream.emit('error', err)\n  })\n}\n\nConnection.prototype.isServer = function isServer () {\n  return this._spdyState.isServer\n}\n\nConnection.prototype.getXForwardedFor = function getXForwardFor () {\n  return this._spdyState.xForward\n}\n\nConnection.prototype.sendXForwardedFor = function sendXForwardedFor (host) {\n  var state = this._spdyState\n  if (state.version !== null) {\n    state.framer.xForwardedFor({ host: host })\n  } else {\n    state.xForward = host\n  }\n}\n\nConnection.prototype.pushPromise = function pushPromise (parent, uri, callback) {\n  var state = this._spdyState\n\n  var stream = this._createStream({\n    request: false,\n    parent: parent,\n    method: uri.method,\n    path: uri.path,\n    host: uri.host,\n    priority: uri.priority,\n    headers: uri.headers,\n    readable: false\n  })\n\n  var err\n\n  // TODO(indutny): deduplicate this logic somehow\n  if (this._isGoaway(stream.id)) {\n    err = new Error('Can\\'t send PUSH_PROMISE after GOAWAY')\n\n    process.nextTick(function () {\n      if (callback) {\n        callback(err)\n      } else {\n        stream.emit('error', err)\n      }\n    })\n    return stream\n  }\n\n  if (uri.push && !state.acceptPush) {\n    err = new Error(\n        'Can\\'t send PUSH_PROMISE, other side won\\'t accept it')\n    process.nextTick(function () {\n      if (callback) { callback(err) } else {\n        stream.emit('error', err)\n      }\n    })\n    return stream\n  }\n\n  stream._sendPush(uri.status, uri.response, function (err) {\n    if (!callback) {\n      if (err) {\n        stream.emit('error', err)\n      }\n      return\n    }\n\n    if (err) { return callback(err) }\n    callback(null, stream)\n  })\n\n  return stream\n}\n\nConnection.prototype.setTimeout = function setTimeout (delay, callback) {\n  var state = this._spdyState\n\n  state.timeout.set(delay, callback)\n}\n"},"sourceMaps":null,"error":null,"hash":"171956afd6f346ce213f910e49e18b89","cacheData":{"env":{}}}