{"id":"../node_modules/postcss-lab-function/index.es.mjs","dependencies":[{"name":"/home/jarri/Desktop/lenovo2020/projects-web/eCommerce/template-store1/package.json","includedInParent":true,"mtime":1594655291184},{"name":"/home/jarri/Desktop/lenovo2020/projects-web/eCommerce/template-store1/node_modules/postcss-lab-function/package.json","includedInParent":true,"mtime":1594306880570},{"name":"@csstools/convert-colors","loc":{"line":1,"column":33},"parent":"/home/jarri/Desktop/lenovo2020/projects-web/eCommerce/template-store1/node_modules/postcss-lab-function/index.es.mjs","resolved":"/home/jarri/Desktop/lenovo2020/projects-web/eCommerce/template-store1/node_modules/@csstools/convert-colors/index.js"},{"name":"postcss","loc":{"line":2,"column":20},"parent":"/home/jarri/Desktop/lenovo2020/projects-web/eCommerce/template-store1/node_modules/postcss-lab-function/index.es.mjs","resolved":"/home/jarri/Desktop/lenovo2020/projects-web/eCommerce/template-store1/node_modules/postcss-lab-function/node_modules/postcss/lib/postcss.js"},{"name":"postcss-values-parser","loc":{"line":3,"column":19},"parent":"/home/jarri/Desktop/lenovo2020/projects-web/eCommerce/template-store1/node_modules/postcss-lab-function/index.es.mjs","resolved":"/home/jarri/Desktop/lenovo2020/projects-web/eCommerce/template-store1/node_modules/postcss-values-parser/lib/index.js"}],"generated":{"js":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar _convertColors = require(\"@csstools/convert-colors\");\n\nvar _postcss = _interopRequireDefault(require(\"postcss\"));\n\nvar _postcssValuesParser = _interopRequireDefault(require(\"postcss-values-parser\"));\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }\n\nfunction _nonIterableSpread() { throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _iterableToArray(iter) { if (typeof Symbol !== \"undefined\" && Symbol.iterator in Object(iter)) return Array.from(iter); }\n\nfunction _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nvar index = _postcss.default.plugin('postcss-lab-function', function (opts) {\n  var preserve = 'preserve' in Object(opts) ? Boolean(opts.preserve) : false;\n  return function (root) {\n    root.walkDecls(function (decl) {\n      var value = decl.value;\n\n      if (colorAnyRegExp.test(value)) {\n        var ast = (0, _postcssValuesParser.default)(value).parse();\n        ast.walkType('func', function (node) {\n          if (colorRegExp.test(node.value)) {\n            var children = node.nodes.slice(1, -1);\n            var isLab = labRegExp.test(node.value);\n            var isGray = grayRegExp.test(node.value);\n            var isFunctionalLAB = !isGray && matchFunctionalLAB(children);\n            var isFunctionalLCH = !isGray && matchFunctionalLCH(children);\n            var isFunctionalGray = isGray && matchFunctionalGray(children);\n\n            if (isFunctionalLAB || isFunctionalLCH) {\n              node.value = 'rgb';\n              var slashNode = children[3];\n              var alphaNode = children[4];\n\n              if (alphaNode) {\n                if (isPercentage(alphaNode) && !isCalc(alphaNode)) {\n                  alphaNode.unit = '';\n                  alphaNode.value = String(alphaNode.value / 100);\n                }\n\n                if (alphaNode.value === '1') {\n                  slashNode.remove();\n                  alphaNode.remove();\n                } else {\n                  node.value += 'a';\n                }\n              }\n\n              if (slashNode && isSlash(slashNode)) {\n                slashNode.replaceWith(newComma());\n              }\n\n              var converter = isLab ? _convertColors.lab2rgb : _convertColors.lch2rgb;\n              var rgbValues = converter.apply(void 0, _toConsumableArray([children[0].value, children[1].value, children[2].value].map(function (number) {\n                return parseFloat(number);\n              }))).map(function (sourceValue) {\n                return Math.max(Math.min(parseInt(sourceValue * 2.55), 255), 0);\n              });\n              children[0].value = String(rgbValues[0]);\n              children[1].value = String(rgbValues[1]);\n              children[2].value = String(rgbValues[2]);\n              node.nodes.splice(3, 0, [newComma()]);\n              node.nodes.splice(2, 0, [newComma()]);\n            } else if (isFunctionalGray) {\n              node.value = 'rgb';\n              var _alphaNode = children[2];\n\n              var _rgbValues = _convertColors.lab2rgb.apply(void 0, _toConsumableArray([children[0].value, 0, 0].map(function (number) {\n                return parseFloat(number);\n              }))).map(function (sourceValue) {\n                return Math.max(Math.min(parseInt(sourceValue * 2.55), 255), 0);\n              });\n\n              node.removeAll().append(newParen('(')).append(newNumber(_rgbValues[0])).append(newComma()).append(newNumber(_rgbValues[1])).append(newComma()).append(newNumber(_rgbValues[2])).append(newParen(')'));\n\n              if (_alphaNode) {\n                if (isPercentage(_alphaNode) && !isCalc(_alphaNode)) {\n                  _alphaNode.unit = '';\n                  _alphaNode.value = String(_alphaNode.value / 100);\n                }\n\n                if (_alphaNode.value !== '1') {\n                  node.value += 'a';\n                  node.insertBefore(node.last, newComma()).insertBefore(node.last, _alphaNode);\n                }\n              }\n            }\n          }\n        });\n        var newValue = String(ast);\n\n        if (preserve) {\n          decl.cloneBefore({\n            value: newValue\n          });\n        } else {\n          decl.value = newValue;\n        }\n      }\n    });\n  };\n});\n\nvar colorAnyRegExp = /(^|[^\\w-])(lab|lch|gray)\\(/i;\nvar colorRegExp = /^(lab|lch|gray)$/i;\nvar labRegExp = /^lab$/i;\nvar grayRegExp = /^gray$/i;\nvar alphaUnitMatch = /^%?$/i;\nvar calcFuncMatch = /^calc$/i;\nvar hueUnitMatch = /^(deg|grad|rad|turn)?$/i;\n\nvar isAlphaValue = function (node) {\n  return isCalc(node) || node.type === 'number' && alphaUnitMatch.test(node.unit);\n};\n\nvar isCalc = function (node) {\n  return node.type === 'func' && calcFuncMatch.test(node.value);\n};\n\nvar isHue = function (node) {\n  return isCalc(node) || node.type === 'number' && hueUnitMatch.test(node.unit);\n};\n\nvar isNumber = function (node) {\n  return isCalc(node) || node.type === 'number' && node.unit === '';\n};\n\nvar isPercentage = function (node) {\n  return isCalc(node) || node.type === 'number' && node.unit === '%';\n};\n\nvar isSlash = function (node) {\n  return node.type === 'operator' && node.value === '/';\n};\n\nvar functionalLABMatch = [isNumber, isNumber, isNumber, isSlash, isAlphaValue];\nvar functionalLCHMatch = [isNumber, isNumber, isHue, isSlash, isAlphaValue];\nvar functionalGrayMatch = [isNumber, isSlash, isAlphaValue];\n\nvar matchFunctionalLAB = function (children) {\n  return children.every(function (child, index) {\n    return typeof functionalLABMatch[index] === 'function' && functionalLABMatch[index](child);\n  });\n};\n\nvar matchFunctionalLCH = function (children) {\n  return children.every(function (child, index) {\n    return typeof functionalLCHMatch[index] === 'function' && functionalLCHMatch[index](child);\n  });\n};\n\nvar matchFunctionalGray = function (children) {\n  return children.every(function (child, index) {\n    return typeof functionalGrayMatch[index] === 'function' && functionalGrayMatch[index](child);\n  });\n};\n\nvar newComma = function () {\n  return _postcssValuesParser.default.comma({\n    value: ','\n  });\n};\n\nvar newNumber = function (value) {\n  return _postcssValuesParser.default.number({\n    value\n  });\n};\n\nvar newParen = function (value) {\n  return _postcssValuesParser.default.paren({\n    value\n  });\n};\n\nvar _default = index;\nexports.default = _default;"},"sourceMaps":null,"error":null,"hash":"0b6598cfa6050752707a7ff8b7bc5d85","cacheData":{"env":{}}}