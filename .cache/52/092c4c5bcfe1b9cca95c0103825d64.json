{"id":"../node_modules/p-locate/index.js","dependencies":[{"name":"/home/jarri/Desktop/lenovo2020/projects-web/eCommerce/template-store1/package.json","includedInParent":true,"mtime":1594655165833},{"name":"/home/jarri/Desktop/lenovo2020/projects-web/eCommerce/template-store1/node_modules/p-locate/package.json","includedInParent":true,"mtime":1594306880338},{"name":"p-limit","loc":{"line":2,"column":23},"parent":"/home/jarri/Desktop/lenovo2020/projects-web/eCommerce/template-store1/node_modules/p-locate/index.js","resolved":"/home/jarri/Desktop/lenovo2020/projects-web/eCommerce/template-store1/node_modules/p-limit/index.js"}],"generated":{"js":"'use strict';\n\nconst pLimit = require('p-limit');\n\nclass EndError extends Error {\n  constructor(value) {\n    super();\n    this.value = value;\n  }\n\n} // the input can also be a promise, so we `Promise.all()` them both\n\n\nconst finder = el => Promise.all(el).then(val => val[1] === true && Promise.reject(new EndError(val[0])));\n\nmodule.exports = (iterable, tester, opts) => {\n  opts = Object.assign({\n    concurrency: Infinity,\n    preserveOrder: true\n  }, opts);\n  const limit = pLimit(opts.concurrency); // start all the promises concurrently with optional limit\n\n  const items = Array.from(iterable).map(el => [el, limit(() => Promise.resolve(el).then(tester))]); // check the promises either serially or concurrently\n\n  const checkLimit = pLimit(opts.preserveOrder ? 1 : Infinity);\n  return Promise.all(items.map(el => checkLimit(() => finder(el)))).then(() => {}).catch(err => err instanceof EndError ? err.value : Promise.reject(err));\n};"},"sourceMaps":null,"error":null,"hash":"097f118d0cbeaf4beff0ba4bc7998868","cacheData":{"env":{}}}