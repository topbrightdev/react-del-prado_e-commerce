{"id":"../node_modules/selfsigned/index.js","dependencies":[{"name":"/home/jarri/Desktop/lenovo2020/projects-web/eCommerce/template-store1/package.json","includedInParent":true,"mtime":1594655291184},{"name":"/home/jarri/Desktop/lenovo2020/projects-web/eCommerce/template-store1/node_modules/selfsigned/package.json","includedInParent":true,"mtime":1594570878734},{"name":"node-forge","loc":{"line":1,"column":20},"parent":"/home/jarri/Desktop/lenovo2020/projects-web/eCommerce/template-store1/node_modules/selfsigned/index.js","resolved":"/home/jarri/Desktop/lenovo2020/projects-web/eCommerce/template-store1/node_modules/node-forge/lib/index.js"}],"generated":{"js":"var forge = require('node-forge');\n\n// a hexString is considered negative if it's most significant bit is 1\n// because serial numbers use ones' complement notation\n// this RFC in section 4.1.2.2 requires serial numbers to be positive\n// http://www.ietf.org/rfc/rfc5280.txt\nfunction toPositiveHex(hexString){\n  var mostSiginficativeHexAsInt = parseInt(hexString[0], 16);\n  if (mostSiginficativeHexAsInt < 8){\n    return hexString;\n  }\n\n  mostSiginficativeHexAsInt -= 8;\n  return mostSiginficativeHexAsInt.toString() + hexString.substring(1);\n}\n\nfunction getAlgorithm(key) {\n  switch (key) {\n    case 'sha256':\n      return forge.md.sha256.create();\n    default:\n      return forge.md.sha1.create();\n  }\n}\n\nexports.generate = function generate(attrs, options, done) {\n  if (typeof attrs === 'function') {\n    done = attrs;\n    attrs = undefined;\n  } else if (typeof options === 'function') {\n    done = options;\n    options = {};\n  }\n\n  options = options || {};\n\n  var generatePem = function (keyPair) {\n    var cert = forge.pki.createCertificate();\n\n    cert.serialNumber = toPositiveHex(forge.util.bytesToHex(forge.random.getBytesSync(9))); // the serial number can be decimal or hex (if preceded by 0x)\n\n    cert.validity.notBefore = new Date();\n    cert.validity.notAfter = new Date();\n    cert.validity.notAfter.setDate(cert.validity.notBefore.getDate() + (options.days || 365));\n\n    attrs = attrs || [{\n      name: 'commonName',\n      value: 'example.org'\n    }, {\n      name: 'countryName',\n      value: 'US'\n    }, {\n      shortName: 'ST',\n      value: 'Virginia'\n    }, {\n      name: 'localityName',\n      value: 'Blacksburg'\n    }, {\n      name: 'organizationName',\n      value: 'Test'\n    }, {\n      shortName: 'OU',\n      value: 'Test'\n    }];\n\n    cert.setSubject(attrs);\n    cert.setIssuer(attrs);\n\n    cert.publicKey = keyPair.publicKey;\n\n    cert.setExtensions(options.extensions || [{\n      name: 'basicConstraints',\n      cA: true\n    }, {\n      name: 'keyUsage',\n      keyCertSign: true,\n      digitalSignature: true,\n      nonRepudiation: true,\n      keyEncipherment: true,\n      dataEncipherment: true\n    }, {\n      name: 'subjectAltName',\n      altNames: [{\n        type: 6, // URI\n        value: 'http://example.org/webid#me'\n      }]\n    }]);\n\n    cert.sign(keyPair.privateKey, getAlgorithm(options && options.algorithm));\n\n    const fingerprint = forge.md.sha1\n                          .create()\n                          .update(forge.asn1.toDer(forge.pki.certificateToAsn1(cert)).getBytes())\n                          .digest()\n                          .toHex()\n                          .match(/.{2}/g)\n                          .join(':');\n\n    var pem = {\n      private:     forge.pki.privateKeyToPem(keyPair.privateKey),\n      public:      forge.pki.publicKeyToPem(keyPair.publicKey),\n      cert:        forge.pki.certificateToPem(cert),\n      fingerprint: fingerprint,\n    };\n\n    if (options && options.pkcs7) {\n      var p7 = forge.pkcs7.createSignedData();\n      p7.addCertificate(cert);\n      pem.pkcs7 = forge.pkcs7.messageToPem(p7);\n    }\n\n    if (options && options.clientCertificate) {\n      var clientkeys = forge.pki.rsa.generateKeyPair(1024);\n      var clientcert = forge.pki.createCertificate();\n      clientcert.serialNumber = toPositiveHex(forge.util.bytesToHex(forge.random.getBytesSync(9)));\n      clientcert.validity.notBefore = new Date();\n      clientcert.validity.notAfter = new Date();\n      clientcert.validity.notAfter.setFullYear(clientcert.validity.notBefore.getFullYear() + 1);\n\n      var clientAttrs = JSON.parse(JSON.stringify(attrs));\n\n      for(var i = 0; i < clientAttrs.length; i++) {\n        if(clientAttrs[i].name === 'commonName') {\n          if( options.clientCertificateCN )\n            clientAttrs[i] = { name: 'commonName', value: options.clientCertificateCN };\n          else\n            clientAttrs[i] = { name: 'commonName', value: 'John Doe jdoe123' };\n        }\n      }\n\n      clientcert.setSubject(clientAttrs);\n\n      // Set the issuer to the parent key\n      clientcert.setIssuer(attrs);\n\n      clientcert.publicKey = clientkeys.publicKey;\n\n      // Sign client cert with root cert\n      clientcert.sign(keyPair.privateKey);\n\n      pem.clientprivate = forge.pki.privateKeyToPem(clientkeys.privateKey);\n      pem.clientpublic = forge.pki.publicKeyToPem(clientkeys.publicKey);\n      pem.clientcert = forge.pki.certificateToPem(clientcert);\n\n      if (options.pkcs7) {\n        var clientp7 = forge.pkcs7.createSignedData();\n        clientp7.addCertificate(clientcert);\n        pem.clientpkcs7 = forge.pkcs7.messageToPem(clientp7);\n      }\n    }\n\n    var caStore = forge.pki.createCaStore();\n    caStore.addCertificate(cert);\n\n    try {\n      forge.pki.verifyCertificateChain(caStore, [cert],\n        function (vfd, depth, chain) {\n          if (vfd !== true) {\n            throw new Error('Certificate could not be verified.');\n          }\n          return true;\n        });\n    }\n    catch(ex) {\n      throw new Error(ex);\n    }\n\n    return pem;\n  };\n\n  var keySize = options.keySize || 1024;\n\n  if (done) { // async scenario\n    return forge.pki.rsa.generateKeyPair({ bits: keySize }, function (err, keyPair) {\n      if (err) { return done(err); }\n\n      try {\n        return done(null, generatePem(keyPair));\n      } catch (ex) {\n        return done(err);\n      }\n    });\n  }\n\n  var keyPair = options.keyPair ? {\n    privateKey: forge.pki.privateKeyFromPem(options.keyPair.privateKey),\n    publicKey: forge.pki.publicKeyFromPem(options.keyPair.publicKey)\n  } : forge.pki.rsa.generateKeyPair(keySize);\n\n  return generatePem(keyPair);\n};\n"},"sourceMaps":null,"error":null,"hash":"9e9c8f0eb48328255cfe43c2d6a7cfe0","cacheData":{"env":{}}}