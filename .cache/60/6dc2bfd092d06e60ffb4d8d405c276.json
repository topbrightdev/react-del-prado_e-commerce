{"id":"../node_modules/webpack/node_modules/chokidar/node_modules/fill-range/index.js","dependencies":[{"name":"/home/jarri/Desktop/lenovo2020/projects-web/eCommerce/template-store1/package.json","includedInParent":true,"mtime":1594655165833},{"name":"/home/jarri/Desktop/lenovo2020/projects-web/eCommerce/template-store1/node_modules/webpack/node_modules/chokidar/node_modules/fill-range/package.json","includedInParent":true,"mtime":1594578778157},{"name":"util","loc":{"line":10,"column":21},"parent":"/home/jarri/Desktop/lenovo2020/projects-web/eCommerce/template-store1/node_modules/webpack/node_modules/chokidar/node_modules/fill-range/index.js","resolved":"/home/jarri/Desktop/lenovo2020/projects-web/eCommerce/template-store1/node_modules/util/util.js"},{"name":"to-regex-range","loc":{"line":11,"column":29},"parent":"/home/jarri/Desktop/lenovo2020/projects-web/eCommerce/template-store1/node_modules/webpack/node_modules/chokidar/node_modules/fill-range/index.js","resolved":"/home/jarri/Desktop/lenovo2020/projects-web/eCommerce/template-store1/node_modules/webpack/node_modules/chokidar/node_modules/to-regex-range/index.js"}],"generated":{"js":"/*!\n * fill-range <https://github.com/jonschlinkert/fill-range>\n *\n * Copyright (c) 2014-present, Jon Schlinkert.\n * Licensed under the MIT License.\n */\n'use strict';\n\nvar util = require('util');\n\nvar toRegexRange = require('to-regex-range');\n\nvar isObject = function isObject(val) {\n  return val !== null && typeof val === 'object' && !Array.isArray(val);\n};\n\nvar transform = function transform(toNumber) {\n  return function (value) {\n    return toNumber === true ? Number(value) : String(value);\n  };\n};\n\nvar isValidValue = function isValidValue(value) {\n  return typeof value === 'number' || typeof value === 'string' && value !== '';\n};\n\nvar isNumber = function isNumber(num) {\n  return Number.isInteger(+num);\n};\n\nvar zeros = function zeros(input) {\n  var value = \"\".concat(input);\n  var index = -1;\n  if (value[0] === '-') value = value.slice(1);\n  if (value === '0') return false;\n\n  while (value[++index] === '0') {\n    ;\n  }\n\n  return index > 0;\n};\n\nvar stringify = function stringify(start, end, options) {\n  if (typeof start === 'string' || typeof end === 'string') {\n    return true;\n  }\n\n  return options.stringify === true;\n};\n\nvar pad = function pad(input, maxLength, toNumber) {\n  if (maxLength > 0) {\n    var dash = input[0] === '-' ? '-' : '';\n    if (dash) input = input.slice(1);\n    input = dash + input.padStart(dash ? maxLength - 1 : maxLength, '0');\n  }\n\n  if (toNumber === false) {\n    return String(input);\n  }\n\n  return input;\n};\n\nvar toMaxLen = function toMaxLen(input, maxLength) {\n  var negative = input[0] === '-' ? '-' : '';\n\n  if (negative) {\n    input = input.slice(1);\n    maxLength--;\n  }\n\n  while (input.length < maxLength) {\n    input = '0' + input;\n  }\n\n  return negative ? '-' + input : input;\n};\n\nvar toSequence = function toSequence(parts, options) {\n  parts.negatives.sort(function (a, b) {\n    return a < b ? -1 : a > b ? 1 : 0;\n  });\n  parts.positives.sort(function (a, b) {\n    return a < b ? -1 : a > b ? 1 : 0;\n  });\n  var prefix = options.capture ? '' : '?:';\n  var positives = '';\n  var negatives = '';\n  var result;\n\n  if (parts.positives.length) {\n    positives = parts.positives.join('|');\n  }\n\n  if (parts.negatives.length) {\n    negatives = \"-(\".concat(prefix).concat(parts.negatives.join('|'), \")\");\n  }\n\n  if (positives && negatives) {\n    result = \"\".concat(positives, \"|\").concat(negatives);\n  } else {\n    result = positives || negatives;\n  }\n\n  if (options.wrap) {\n    return \"(\".concat(prefix).concat(result, \")\");\n  }\n\n  return result;\n};\n\nvar toRange = function toRange(a, b, isNumbers, options) {\n  if (isNumbers) {\n    return toRegexRange(a, b, {\n      wrap: false,\n      ...options\n    });\n  }\n\n  var start = String.fromCharCode(a);\n  if (a === b) return start;\n  var stop = String.fromCharCode(b);\n  return \"[\".concat(start, \"-\").concat(stop, \"]\");\n};\n\nvar toRegex = function toRegex(start, end, options) {\n  if (Array.isArray(start)) {\n    var wrap = options.wrap === true;\n    var prefix = options.capture ? '' : '?:';\n    return wrap ? \"(\".concat(prefix).concat(start.join('|'), \")\") : start.join('|');\n  }\n\n  return toRegexRange(start, end, options);\n};\n\nvar rangeError = function rangeError() {\n  return new RangeError('Invalid range arguments: ' + util.inspect.apply(util, arguments));\n};\n\nvar invalidRange = function invalidRange(start, end, options) {\n  if (options.strictRanges === true) throw rangeError([start, end]);\n  return [];\n};\n\nvar invalidStep = function invalidStep(step, options) {\n  if (options.strictRanges === true) {\n    throw new TypeError(\"Expected step \\\"\".concat(step, \"\\\" to be a number\"));\n  }\n\n  return [];\n};\n\nvar fillNumbers = function fillNumbers(start, end) {\n  var step = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;\n  var options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n  var a = Number(start);\n  var b = Number(end);\n\n  if (!Number.isInteger(a) || !Number.isInteger(b)) {\n    if (options.strictRanges === true) throw rangeError([start, end]);\n    return [];\n  } // fix negative zero\n\n\n  if (a === 0) a = 0;\n  if (b === 0) b = 0;\n  var descending = a > b;\n  var startString = String(start);\n  var endString = String(end);\n  var stepString = String(step);\n  step = Math.max(Math.abs(step), 1);\n  var padded = zeros(startString) || zeros(endString) || zeros(stepString);\n  var maxLen = padded ? Math.max(startString.length, endString.length, stepString.length) : 0;\n  var toNumber = padded === false && stringify(start, end, options) === false;\n  var format = options.transform || transform(toNumber);\n\n  if (options.toRegex && step === 1) {\n    return toRange(toMaxLen(start, maxLen), toMaxLen(end, maxLen), true, options);\n  }\n\n  var parts = {\n    negatives: [],\n    positives: []\n  };\n\n  var push = function push(num) {\n    return parts[num < 0 ? 'negatives' : 'positives'].push(Math.abs(num));\n  };\n\n  var range = [];\n  var index = 0;\n\n  while (descending ? a >= b : a <= b) {\n    if (options.toRegex === true && step > 1) {\n      push(a);\n    } else {\n      range.push(pad(format(a, index), maxLen, toNumber));\n    }\n\n    a = descending ? a - step : a + step;\n    index++;\n  }\n\n  if (options.toRegex === true) {\n    return step > 1 ? toSequence(parts, options) : toRegex(range, null, {\n      wrap: false,\n      ...options\n    });\n  }\n\n  return range;\n};\n\nvar fillLetters = function fillLetters(start, end) {\n  var step = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;\n  var options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n\n  if (!isNumber(start) && start.length > 1 || !isNumber(end) && end.length > 1) {\n    return invalidRange(start, end, options);\n  }\n\n  var format = options.transform || function (val) {\n    return String.fromCharCode(val);\n  };\n\n  var a = \"\".concat(start).charCodeAt(0);\n  var b = \"\".concat(end).charCodeAt(0);\n  var descending = a > b;\n  var min = Math.min(a, b);\n  var max = Math.max(a, b);\n\n  if (options.toRegex && step === 1) {\n    return toRange(min, max, false, options);\n  }\n\n  var range = [];\n  var index = 0;\n\n  while (descending ? a >= b : a <= b) {\n    range.push(format(a, index));\n    a = descending ? a - step : a + step;\n    index++;\n  }\n\n  if (options.toRegex === true) {\n    return toRegex(range, null, {\n      wrap: false,\n      options\n    });\n  }\n\n  return range;\n};\n\nvar fill = function fill(start, end, step) {\n  var options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n\n  if (end == null && isValidValue(start)) {\n    return [start];\n  }\n\n  if (!isValidValue(start) || !isValidValue(end)) {\n    return invalidRange(start, end, options);\n  }\n\n  if (typeof step === 'function') {\n    return fill(start, end, 1, {\n      transform: step\n    });\n  }\n\n  if (isObject(step)) {\n    return fill(start, end, 0, step);\n  }\n\n  var opts = { ...options\n  };\n  if (opts.capture === true) opts.wrap = true;\n  step = step || opts.step || 1;\n\n  if (!isNumber(step)) {\n    if (step != null && !isObject(step)) return invalidStep(step, opts);\n    return fill(start, end, 1, step);\n  }\n\n  if (isNumber(start) && isNumber(end)) {\n    return fillNumbers(start, end, step, opts);\n  }\n\n  return fillLetters(start, end, Math.max(Math.abs(step), 1), opts);\n};\n\nmodule.exports = fill;"},"sourceMaps":null,"error":null,"hash":"9a1032bbf04420544658f7180aecb492","cacheData":{"env":{}}}