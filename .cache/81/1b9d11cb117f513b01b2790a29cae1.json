{"id":"../node_modules/autoprefixer/lib/processor.js","dependencies":[{"name":"/home/jarri/Desktop/lenovo2020/projects-web/eCommerce/template-store1/package.json","includedInParent":true,"mtime":1594655165833},{"name":"/home/jarri/Desktop/lenovo2020/projects-web/eCommerce/template-store1/node_modules/autoprefixer/package.json","includedInParent":true,"mtime":1594570878686},{"name":"./value","loc":{"line":3,"column":20},"parent":"/home/jarri/Desktop/lenovo2020/projects-web/eCommerce/template-store1/node_modules/autoprefixer/lib/processor.js","resolved":"/home/jarri/Desktop/lenovo2020/projects-web/eCommerce/template-store1/node_modules/autoprefixer/lib/value.js"},{"name":"./hacks/grid-utils","loc":{"line":5,"column":26},"parent":"/home/jarri/Desktop/lenovo2020/projects-web/eCommerce/template-store1/node_modules/autoprefixer/lib/processor.js","resolved":"/home/jarri/Desktop/lenovo2020/projects-web/eCommerce/template-store1/node_modules/autoprefixer/lib/hacks/grid-utils.js"}],"generated":{"js":"\"use strict\";\n\nvar Value = require('./value');\n\nvar insertAreas = require('./hacks/grid-utils').insertAreas;\n\nvar OLD_LINEAR = /(^|[^-])linear-gradient\\(\\s*(top|left|right|bottom)/i;\nvar OLD_RADIAL = /(^|[^-])radial-gradient\\(\\s*\\d+(\\w*|%)\\s+\\d+(\\w*|%)\\s*,/i;\nvar RADIAL_BLOCK = /\\(((?:[^)(]+|\\((?:[^)(]+|\\([^)(]*\\))*\\))*)\\)/i;\nvar IGNORE_NEXT = /(!\\s*)?autoprefixer:\\s*ignore\\s+next/i;\nvar SIZES = ['width', 'height', 'min-width', 'max-width', 'min-height', 'max-height', 'inline-size', 'min-inline-size', 'max-inline-size', 'block-size', 'min-block-size', 'max-block-size'];\n\nvar Processor = /*#__PURE__*/function () {\n  function Processor(prefixes) {\n    this.prefixes = prefixes;\n  }\n  /**\n   * Add necessary prefixes\n   */\n\n\n  var _proto = Processor.prototype;\n\n  _proto.add = function add(css, result) {\n    var _this = this; // At-rules\n\n\n    var resolution = this.prefixes.add['@resolution'];\n    var keyframes = this.prefixes.add['@keyframes'];\n    var viewport = this.prefixes.add['@viewport'];\n    var supports = this.prefixes.add['@supports'];\n    css.walkAtRules(function (rule) {\n      if (rule.name === 'keyframes') {\n        if (!_this.disabled(rule, result)) {\n          return keyframes && keyframes.process(rule);\n        }\n      } else if (rule.name === 'viewport') {\n        if (!_this.disabled(rule, result)) {\n          return viewport && viewport.process(rule);\n        }\n      } else if (rule.name === 'supports') {\n        if (_this.prefixes.options.supports !== false && !_this.disabled(rule, result)) {\n          return supports.process(rule);\n        }\n      } else if (rule.name === 'media' && rule.params.indexOf('-resolution') !== -1) {\n        if (!_this.disabled(rule, result)) {\n          return resolution && resolution.process(rule);\n        }\n      }\n\n      return undefined;\n    }); // Selectors\n\n    css.walkRules(function (rule) {\n      if (_this.disabled(rule, result)) return undefined;\n      return _this.prefixes.add.selectors.map(function (selector) {\n        return selector.process(rule, result);\n      });\n    });\n\n    function insideGrid(decl) {\n      return decl.parent.some(function (subDecl) {\n        var displayGrid = subDecl.prop === 'display' && /(inline-)?grid/.test(subDecl.value);\n        var gridTemplate = /^grid-template/.test(subDecl.prop);\n        var gridGap = /^grid-([A-z]+-)?gap/.test(subDecl.prop);\n        return displayGrid || gridTemplate || gridGap;\n      });\n    }\n\n    var gridPrefixes = this.gridStatus(css, result) && this.prefixes.add['grid-area'] && this.prefixes.add['grid-area'].prefixes;\n    css.walkDecls(function (decl) {\n      if (_this.disabledDecl(decl, result)) return undefined;\n      var prop = decl.prop;\n      var value = decl.value;\n\n      if (prop === 'grid-row-span') {\n        result.warn('grid-row-span is not part of final Grid Layout. Use grid-row.', {\n          node: decl\n        });\n        return undefined;\n      } else if (prop === 'grid-column-span') {\n        result.warn('grid-column-span is not part of final Grid Layout. Use grid-column.', {\n          node: decl\n        });\n        return undefined;\n      } else if (prop === 'display' && value === 'box') {\n        result.warn('You should write display: flex by final spec ' + 'instead of display: box', {\n          node: decl\n        });\n        return undefined;\n      } else if (prop === 'text-emphasis-position') {\n        if (value === 'under' || value === 'over') {\n          result.warn('You should use 2 values for text-emphasis-position ' + 'For example, `under left` instead of just `under`.', {\n            node: decl\n          });\n        }\n      } else {\n        if (gridPrefixes) {\n          if (/^(align|justify|place)-items$/.test(prop) && insideGrid(decl)) {\n            var fixed = prop.replace('-items', '-self');\n            result.warn(\"IE does not support \" + prop + \" on grid containers. \" + (\"Try using \" + fixed + \" on child elements instead: \") + (decl.parent.selector + \" > * { \" + fixed + \": \" + decl.value + \" }\"), {\n              node: decl\n            });\n          } else if (/^(align|justify|place)-content$/.test(prop) && insideGrid(decl)) {\n            result.warn(\"IE does not support \" + decl.prop + \" on grid containers\", {\n              node: decl\n            });\n          } else if (prop === 'display' && decl.value === 'contents') {\n            result.warn('Please do not use display: contents; ' + 'if you have grid setting enabled', {\n              node: decl\n            });\n            return undefined;\n          } else if (prop === 'grid-auto-columns') {\n            result.warn('grid-auto-columns is not supported by IE', {\n              node: decl\n            });\n            return undefined;\n          } else if (prop === 'grid-auto-rows') {\n            result.warn('grid-auto-rows is not supported by IE', {\n              node: decl\n            });\n            return undefined;\n          } else if (prop === 'grid-auto-flow') {\n            result.warn('grid-auto-flow is not supported by IE', {\n              node: decl\n            });\n            return undefined;\n          } else if (value.indexOf('auto-fit') !== -1) {\n            result.warn('auto-fit value is not supported by IE', {\n              node: decl,\n              word: 'auto-fit'\n            });\n            return undefined;\n          } else if (value.indexOf('auto-fill') !== -1) {\n            result.warn('auto-fill value is not supported by IE', {\n              node: decl,\n              word: 'auto-fill'\n            });\n            return undefined;\n          }\n        }\n\n        if (value.indexOf('radial-gradient') !== -1) {\n          if (OLD_RADIAL.test(decl.value)) {\n            result.warn('Gradient has outdated direction syntax. ' + 'New syntax is like `closest-side at 0 0` ' + 'instead of `0 0, closest-side`.', {\n              node: decl\n            });\n          } else {\n            var match = value.match(RADIAL_BLOCK);\n\n            if (match) {\n              if (/cover/.test(match[1])) {\n                result.warn('Gradient has outdated direction syntax. ' + 'Replace `cover` to `farthest-corner`.', {\n                  node: decl\n                });\n              } else if (/contain/.test(match[1])) {\n                result.warn('Gradient has outdated direction syntax. ' + 'Replace `contain` to `closest-side`.', {\n                  node: decl\n                });\n              }\n            }\n          }\n        }\n\n        if (value.indexOf('linear-gradient') !== -1) {\n          if (OLD_LINEAR.test(value)) {\n            result.warn('Gradient has outdated direction syntax. ' + 'New syntax is like `to left` instead of `right`.', {\n              node: decl\n            });\n          }\n        }\n      }\n\n      if (SIZES.indexOf(decl.prop) !== -1) {\n        if (decl.value.indexOf('-fill-available') === -1) {\n          if (decl.value.indexOf('fill-available') !== -1) {\n            result.warn('Replace fill-available to stretch, ' + 'because spec had been changed', {\n              node: decl\n            });\n          } else if (decl.value.indexOf('fill') !== -1) {\n            result.warn('Replace fill to stretch, because spec had been changed', {\n              node: decl\n            });\n          }\n        }\n      }\n\n      var prefixer;\n\n      if (decl.prop === 'transition' || decl.prop === 'transition-property') {\n        // Transition\n        return _this.prefixes.transition.add(decl, result);\n      } else if (decl.prop === 'align-self') {\n        // align-self flexbox or grid\n        var display = _this.displayType(decl);\n\n        if (display !== 'grid' && _this.prefixes.options.flexbox !== false) {\n          prefixer = _this.prefixes.add['align-self'];\n\n          if (prefixer && prefixer.prefixes) {\n            prefixer.process(decl);\n          }\n        }\n\n        if (display !== 'flex' && _this.gridStatus(decl, result) !== false) {\n          prefixer = _this.prefixes.add['grid-row-align'];\n\n          if (prefixer && prefixer.prefixes) {\n            return prefixer.process(decl, result);\n          }\n        }\n      } else if (decl.prop === 'justify-self') {\n        // justify-self flexbox or grid\n        var _display = _this.displayType(decl);\n\n        if (_display !== 'flex' && _this.gridStatus(decl, result) !== false) {\n          prefixer = _this.prefixes.add['grid-column-align'];\n\n          if (prefixer && prefixer.prefixes) {\n            return prefixer.process(decl, result);\n          }\n        }\n      } else if (decl.prop === 'place-self') {\n        prefixer = _this.prefixes.add['place-self'];\n\n        if (prefixer && prefixer.prefixes && _this.gridStatus(decl, result) !== false) {\n          return prefixer.process(decl, result);\n        }\n      } else {\n        // Properties\n        prefixer = _this.prefixes.add[decl.prop];\n\n        if (prefixer && prefixer.prefixes) {\n          return prefixer.process(decl, result);\n        }\n      }\n\n      return undefined;\n    }); // Insert grid-area prefixes. We need to be able to store the different\n    // rules as a data and hack API is not enough for this\n\n    if (this.gridStatus(css, result) === true) {\n      insertAreas(css, this.disabled);\n    } // Values\n\n\n    return css.walkDecls(function (decl) {\n      if (_this.disabledValue(decl, result)) return;\n\n      var unprefixed = _this.prefixes.unprefixed(decl.prop);\n\n      for (var _iterator = _this.prefixes.values('add', unprefixed), _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : _iterator[Symbol.iterator]();;) {\n        var _ref;\n\n        if (_isArray) {\n          if (_i >= _iterator.length) break;\n          _ref = _iterator[_i++];\n        } else {\n          _i = _iterator.next();\n          if (_i.done) break;\n          _ref = _i.value;\n        }\n\n        var value = _ref;\n        value.process(decl, result);\n      }\n\n      Value.save(_this.prefixes, decl);\n    });\n  };\n  /**\n   * Remove unnecessary pefixes\n   */\n\n\n  _proto.remove = function remove(css, result) {\n    var _this2 = this; // At-rules\n\n\n    var resolution = this.prefixes.remove['@resolution'];\n    css.walkAtRules(function (rule, i) {\n      if (_this2.prefixes.remove[\"@\" + rule.name]) {\n        if (!_this2.disabled(rule, result)) {\n          rule.parent.removeChild(i);\n        }\n      } else if (rule.name === 'media' && rule.params.indexOf('-resolution') !== -1 && resolution) {\n        resolution.clean(rule);\n      }\n    }); // Selectors\n\n    var _loop = function _loop() {\n      if (_isArray2) {\n        if (_i2 >= _iterator2.length) return \"break\";\n        _ref2 = _iterator2[_i2++];\n      } else {\n        _i2 = _iterator2.next();\n        if (_i2.done) return \"break\";\n        _ref2 = _i2.value;\n      }\n\n      var checker = _ref2;\n      css.walkRules(function (rule, i) {\n        if (checker.check(rule)) {\n          if (!_this2.disabled(rule, result)) {\n            rule.parent.removeChild(i);\n          }\n        }\n      });\n    };\n\n    for (var _iterator2 = this.prefixes.remove.selectors, _isArray2 = Array.isArray(_iterator2), _i2 = 0, _iterator2 = _isArray2 ? _iterator2 : _iterator2[Symbol.iterator]();;) {\n      var _ref2;\n\n      var _ret = _loop();\n\n      if (_ret === \"break\") break;\n    }\n\n    return css.walkDecls(function (decl, i) {\n      if (_this2.disabled(decl, result)) return;\n      var rule = decl.parent;\n\n      var unprefixed = _this2.prefixes.unprefixed(decl.prop); // Transition\n\n\n      if (decl.prop === 'transition' || decl.prop === 'transition-property') {\n        _this2.prefixes.transition.remove(decl);\n      } // Properties\n\n\n      if (_this2.prefixes.remove[decl.prop] && _this2.prefixes.remove[decl.prop].remove) {\n        var notHack = _this2.prefixes.group(decl).down(function (other) {\n          return _this2.prefixes.normalize(other.prop) === unprefixed;\n        });\n\n        if (unprefixed === 'flex-flow') {\n          notHack = true;\n        }\n\n        if (notHack && !_this2.withHackValue(decl)) {\n          if (decl.raw('before').indexOf('\\n') > -1) {\n            _this2.reduceSpaces(decl);\n          }\n\n          rule.removeChild(i);\n          return;\n        }\n      } // Values\n\n\n      for (var _iterator3 = _this2.prefixes.values('remove', unprefixed), _isArray3 = Array.isArray(_iterator3), _i3 = 0, _iterator3 = _isArray3 ? _iterator3 : _iterator3[Symbol.iterator]();;) {\n        var _ref3;\n\n        if (_isArray3) {\n          if (_i3 >= _iterator3.length) break;\n          _ref3 = _iterator3[_i3++];\n        } else {\n          _i3 = _iterator3.next();\n          if (_i3.done) break;\n          _ref3 = _i3.value;\n        }\n\n        var checker = _ref3;\n\n        if (!checker.check(decl.value)) {\n          continue;\n        }\n\n        unprefixed = checker.unprefixed;\n\n        var _notHack = _this2.prefixes.group(decl).down(function (other) {\n          return other.value.indexOf(unprefixed) !== -1;\n        });\n\n        if (_notHack) {\n          rule.removeChild(i);\n          return;\n        }\n      }\n    });\n  };\n  /**\n   * Some rare old values, which is not in standard\n   */\n\n\n  _proto.withHackValue = function withHackValue(decl) {\n    return decl.prop === '-webkit-background-clip' && decl.value === 'text';\n  };\n  /**\n   * Check for grid/flexbox options.\n   */\n\n\n  _proto.disabledValue = function disabledValue(node, result) {\n    if (this.gridStatus(node, result) === false && node.type === 'decl') {\n      if (node.prop === 'display' && node.value.indexOf('grid') !== -1) {\n        return true;\n      }\n    }\n\n    if (this.prefixes.options.flexbox === false && node.type === 'decl') {\n      if (node.prop === 'display' && node.value.indexOf('flex') !== -1) {\n        return true;\n      }\n    }\n\n    return this.disabled(node, result);\n  };\n  /**\n   * Check for grid/flexbox options.\n   */\n\n\n  _proto.disabledDecl = function disabledDecl(node, result) {\n    if (this.gridStatus(node, result) === false && node.type === 'decl') {\n      if (node.prop.indexOf('grid') !== -1 || node.prop === 'justify-items') {\n        return true;\n      }\n    }\n\n    if (this.prefixes.options.flexbox === false && node.type === 'decl') {\n      var other = ['order', 'justify-content', 'align-items', 'align-content'];\n\n      if (node.prop.indexOf('flex') !== -1 || other.indexOf(node.prop) !== -1) {\n        return true;\n      }\n    }\n\n    return this.disabled(node, result);\n  };\n  /**\n   * Check for control comment and global options\n   */\n\n\n  _proto.disabled = function disabled(node, result) {\n    if (!node) return false;\n\n    if (node._autoprefixerDisabled !== undefined) {\n      return node._autoprefixerDisabled;\n    }\n\n    if (node.parent) {\n      var p = node.prev();\n\n      if (p && p.type === 'comment' && IGNORE_NEXT.test(p.text)) {\n        node._autoprefixerDisabled = true;\n        node._autoprefixerSelfDisabled = true;\n        return true;\n      }\n    }\n\n    var value = null;\n\n    if (node.nodes) {\n      var status;\n      node.each(function (i) {\n        if (i.type !== 'comment') return;\n\n        if (/(!\\s*)?autoprefixer:\\s*(off|on)/i.test(i.text)) {\n          if (typeof status !== 'undefined') {\n            result.warn('Second Autoprefixer control comment ' + 'was ignored. Autoprefixer applies control ' + 'comment to whole block, not to next rules.', {\n              node: i\n            });\n          } else {\n            status = /on/i.test(i.text);\n          }\n        }\n      });\n\n      if (status !== undefined) {\n        value = !status;\n      }\n    }\n\n    if (!node.nodes || value === null) {\n      if (node.parent) {\n        var isParentDisabled = this.disabled(node.parent, result);\n\n        if (node.parent._autoprefixerSelfDisabled === true) {\n          value = false;\n        } else {\n          value = isParentDisabled;\n        }\n      } else {\n        value = false;\n      }\n    }\n\n    node._autoprefixerDisabled = value;\n    return value;\n  };\n  /**\n   * Normalize spaces in cascade declaration group\n   */\n\n\n  _proto.reduceSpaces = function reduceSpaces(decl) {\n    var stop = false;\n    this.prefixes.group(decl).up(function () {\n      stop = true;\n      return true;\n    });\n\n    if (stop) {\n      return;\n    }\n\n    var parts = decl.raw('before').split('\\n');\n    var prevMin = parts[parts.length - 1].length;\n    var diff = false;\n    this.prefixes.group(decl).down(function (other) {\n      parts = other.raw('before').split('\\n');\n      var last = parts.length - 1;\n\n      if (parts[last].length > prevMin) {\n        if (diff === false) {\n          diff = parts[last].length - prevMin;\n        }\n\n        parts[last] = parts[last].slice(0, -diff);\n        other.raws.before = parts.join('\\n');\n      }\n    });\n  };\n  /**\n   * Is it flebox or grid rule\n   */\n\n\n  _proto.displayType = function displayType(decl) {\n    for (var _iterator4 = decl.parent.nodes, _isArray4 = Array.isArray(_iterator4), _i4 = 0, _iterator4 = _isArray4 ? _iterator4 : _iterator4[Symbol.iterator]();;) {\n      var _ref4;\n\n      if (_isArray4) {\n        if (_i4 >= _iterator4.length) break;\n        _ref4 = _iterator4[_i4++];\n      } else {\n        _i4 = _iterator4.next();\n        if (_i4.done) break;\n        _ref4 = _i4.value;\n      }\n\n      var i = _ref4;\n\n      if (i.prop !== 'display') {\n        continue;\n      }\n\n      if (i.value.indexOf('flex') !== -1) {\n        return 'flex';\n      }\n\n      if (i.value.indexOf('grid') !== -1) {\n        return 'grid';\n      }\n    }\n\n    return false;\n  };\n  /**\n   * Set grid option via control comment\n   */\n\n\n  _proto.gridStatus = function gridStatus(node, result) {\n    if (!node) return false;\n\n    if (node._autoprefixerGridStatus !== undefined) {\n      return node._autoprefixerGridStatus;\n    }\n\n    var value = null;\n\n    if (node.nodes) {\n      var status;\n      node.each(function (i) {\n        if (i.type !== 'comment') return;\n\n        if (/(!\\s*)?autoprefixer\\s*grid:\\s*(off|on)/i.test(i.text)) {\n          if (typeof status !== 'undefined') {\n            result.warn('Second Autoprefixer grid control comment ' + 'was ignored. Autoprefixer applies control ' + 'comment to whole block, not to next rules.', {\n              node: i\n            });\n          } else {\n            status = /on/i.test(i.text);\n          }\n        }\n      });\n\n      if (status !== undefined) {\n        value = status;\n      }\n    }\n\n    if (node.type === 'atrule' && node.name === 'supports') {\n      var params = node.params;\n\n      if (params.indexOf('grid') !== -1 && params.indexOf('auto') !== -1) {\n        value = false;\n      }\n    }\n\n    if (!node.nodes || value === null) {\n      if (node.parent) {\n        var isParentGrid = this.gridStatus(node.parent, result);\n\n        if (node.parent._autoprefixerSelfDisabled === true) {\n          value = false;\n        } else {\n          value = isParentGrid;\n        }\n      } else {\n        value = this.prefixes.options.grid;\n      }\n    }\n\n    node._autoprefixerGridStatus = value;\n    return value;\n  };\n\n  return Processor;\n}();\n\nmodule.exports = Processor;"},"sourceMaps":null,"error":null,"hash":"fd3e6ec89565fdc41ae136aa86a2a6f6","cacheData":{"env":{}}}