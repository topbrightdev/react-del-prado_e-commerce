{"id":"../node_modules/postcss-values-parser/lib/parser.js","dependencies":[{"name":"/home/jarri/Desktop/lenovo2020/projects-web/eCommerce/template-store1/package.json","includedInParent":true,"mtime":1594655165833},{"name":"/home/jarri/Desktop/lenovo2020/projects-web/eCommerce/template-store1/node_modules/postcss-values-parser/package.json","includedInParent":true,"mtime":1594570879022},{"name":"./root","loc":{"line":3,"column":21},"parent":"/home/jarri/Desktop/lenovo2020/projects-web/eCommerce/template-store1/node_modules/postcss-values-parser/lib/parser.js","resolved":"/home/jarri/Desktop/lenovo2020/projects-web/eCommerce/template-store1/node_modules/postcss-values-parser/lib/root.js"},{"name":"./value","loc":{"line":4,"column":22},"parent":"/home/jarri/Desktop/lenovo2020/projects-web/eCommerce/template-store1/node_modules/postcss-values-parser/lib/parser.js","resolved":"/home/jarri/Desktop/lenovo2020/projects-web/eCommerce/template-store1/node_modules/postcss-values-parser/lib/value.js"},{"name":"./atword","loc":{"line":6,"column":23},"parent":"/home/jarri/Desktop/lenovo2020/projects-web/eCommerce/template-store1/node_modules/postcss-values-parser/lib/parser.js","resolved":"/home/jarri/Desktop/lenovo2020/projects-web/eCommerce/template-store1/node_modules/postcss-values-parser/lib/atword.js"},{"name":"./colon","loc":{"line":7,"column":22},"parent":"/home/jarri/Desktop/lenovo2020/projects-web/eCommerce/template-store1/node_modules/postcss-values-parser/lib/parser.js","resolved":"/home/jarri/Desktop/lenovo2020/projects-web/eCommerce/template-store1/node_modules/postcss-values-parser/lib/colon.js"},{"name":"./comma","loc":{"line":8,"column":22},"parent":"/home/jarri/Desktop/lenovo2020/projects-web/eCommerce/template-store1/node_modules/postcss-values-parser/lib/parser.js","resolved":"/home/jarri/Desktop/lenovo2020/projects-web/eCommerce/template-store1/node_modules/postcss-values-parser/lib/comma.js"},{"name":"./comment","loc":{"line":9,"column":24},"parent":"/home/jarri/Desktop/lenovo2020/projects-web/eCommerce/template-store1/node_modules/postcss-values-parser/lib/parser.js","resolved":"/home/jarri/Desktop/lenovo2020/projects-web/eCommerce/template-store1/node_modules/postcss-values-parser/lib/comment.js"},{"name":"./function","loc":{"line":10,"column":21},"parent":"/home/jarri/Desktop/lenovo2020/projects-web/eCommerce/template-store1/node_modules/postcss-values-parser/lib/parser.js","resolved":"/home/jarri/Desktop/lenovo2020/projects-web/eCommerce/template-store1/node_modules/postcss-values-parser/lib/function.js"},{"name":"./number","loc":{"line":11,"column":22},"parent":"/home/jarri/Desktop/lenovo2020/projects-web/eCommerce/template-store1/node_modules/postcss-values-parser/lib/parser.js","resolved":"/home/jarri/Desktop/lenovo2020/projects-web/eCommerce/template-store1/node_modules/postcss-values-parser/lib/number.js"},{"name":"./operator","loc":{"line":12,"column":25},"parent":"/home/jarri/Desktop/lenovo2020/projects-web/eCommerce/template-store1/node_modules/postcss-values-parser/lib/parser.js","resolved":"/home/jarri/Desktop/lenovo2020/projects-web/eCommerce/template-store1/node_modules/postcss-values-parser/lib/operator.js"},{"name":"./paren","loc":{"line":13,"column":22},"parent":"/home/jarri/Desktop/lenovo2020/projects-web/eCommerce/template-store1/node_modules/postcss-values-parser/lib/parser.js","resolved":"/home/jarri/Desktop/lenovo2020/projects-web/eCommerce/template-store1/node_modules/postcss-values-parser/lib/paren.js"},{"name":"./string","loc":{"line":14,"column":20},"parent":"/home/jarri/Desktop/lenovo2020/projects-web/eCommerce/template-store1/node_modules/postcss-values-parser/lib/parser.js","resolved":"/home/jarri/Desktop/lenovo2020/projects-web/eCommerce/template-store1/node_modules/postcss-values-parser/lib/string.js"},{"name":"./word","loc":{"line":15,"column":21},"parent":"/home/jarri/Desktop/lenovo2020/projects-web/eCommerce/template-store1/node_modules/postcss-values-parser/lib/parser.js","resolved":"/home/jarri/Desktop/lenovo2020/projects-web/eCommerce/template-store1/node_modules/postcss-values-parser/lib/word.js"},{"name":"./unicode-range","loc":{"line":16,"column":29},"parent":"/home/jarri/Desktop/lenovo2020/projects-web/eCommerce/template-store1/node_modules/postcss-values-parser/lib/parser.js","resolved":"/home/jarri/Desktop/lenovo2020/projects-web/eCommerce/template-store1/node_modules/postcss-values-parser/lib/unicode-range.js"},{"name":"./tokenize","loc":{"line":18,"column":25},"parent":"/home/jarri/Desktop/lenovo2020/projects-web/eCommerce/template-store1/node_modules/postcss-values-parser/lib/parser.js","resolved":"/home/jarri/Desktop/lenovo2020/projects-web/eCommerce/template-store1/node_modules/postcss-values-parser/lib/tokenize.js"},{"name":"flatten","loc":{"line":20,"column":24},"parent":"/home/jarri/Desktop/lenovo2020/projects-web/eCommerce/template-store1/node_modules/postcss-values-parser/lib/parser.js","resolved":"/home/jarri/Desktop/lenovo2020/projects-web/eCommerce/template-store1/node_modules/flatten/index.js"},{"name":"indexes-of","loc":{"line":21,"column":26},"parent":"/home/jarri/Desktop/lenovo2020/projects-web/eCommerce/template-store1/node_modules/postcss-values-parser/lib/parser.js","resolved":"/home/jarri/Desktop/lenovo2020/projects-web/eCommerce/template-store1/node_modules/indexes-of/index.js"},{"name":"uniq","loc":{"line":22,"column":21},"parent":"/home/jarri/Desktop/lenovo2020/projects-web/eCommerce/template-store1/node_modules/postcss-values-parser/lib/parser.js","resolved":"/home/jarri/Desktop/lenovo2020/projects-web/eCommerce/template-store1/node_modules/uniq/uniq.js"},{"name":"./errors/ParserError","loc":{"line":23,"column":28},"parent":"/home/jarri/Desktop/lenovo2020/projects-web/eCommerce/template-store1/node_modules/postcss-values-parser/lib/parser.js","resolved":"/home/jarri/Desktop/lenovo2020/projects-web/eCommerce/template-store1/node_modules/postcss-values-parser/lib/errors/ParserError.js"}],"generated":{"js":"'use strict';\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nvar Root = require('./root');\n\nvar Value = require('./value');\n\nvar AtWord = require('./atword');\n\nvar Colon = require('./colon');\n\nvar Comma = require('./comma');\n\nvar Comment = require('./comment');\n\nvar Func = require('./function');\n\nvar Numbr = require('./number');\n\nvar Operator = require('./operator');\n\nvar Paren = require('./paren');\n\nvar Str = require('./string');\n\nvar Word = require('./word');\n\nvar UnicodeRange = require('./unicode-range');\n\nvar tokenize = require('./tokenize');\n\nvar flatten = require('flatten');\n\nvar indexesOf = require('indexes-of');\n\nvar uniq = require('uniq');\n\nvar ParserError = require('./errors/ParserError');\n\nfunction sortAscending(list) {\n  return list.sort(function (a, b) {\n    return a - b;\n  });\n}\n\nmodule.exports = /*#__PURE__*/function () {\n  function Parser(input, options) {\n    _classCallCheck(this, Parser);\n\n    var defaults = {\n      loose: false\n    }; // cache needs to be an array for values with more than 1 level of function nesting\n\n    this.cache = [];\n    this.input = input;\n    this.options = Object.assign({}, defaults, options);\n    this.position = 0; // we'll use this to keep track of the paren balance\n\n    this.unbalanced = 0;\n    this.root = new Root();\n    var value = new Value();\n    this.root.append(value);\n    this.current = value;\n    this.tokens = tokenize(input, this.options);\n  }\n\n  _createClass(Parser, [{\n    key: \"parse\",\n    value: function parse() {\n      return this.loop();\n    }\n  }, {\n    key: \"colon\",\n    value: function colon() {\n      var token = this.currToken;\n      this.newNode(new Colon({\n        value: token[1],\n        source: {\n          start: {\n            line: token[2],\n            column: token[3]\n          },\n          end: {\n            line: token[4],\n            column: token[5]\n          }\n        },\n        sourceIndex: token[6]\n      }));\n      this.position++;\n    }\n  }, {\n    key: \"comma\",\n    value: function comma() {\n      var token = this.currToken;\n      this.newNode(new Comma({\n        value: token[1],\n        source: {\n          start: {\n            line: token[2],\n            column: token[3]\n          },\n          end: {\n            line: token[4],\n            column: token[5]\n          }\n        },\n        sourceIndex: token[6]\n      }));\n      this.position++;\n    }\n  }, {\n    key: \"comment\",\n    value: function comment() {\n      var inline = false,\n          value = this.currToken[1].replace(/\\/\\*|\\*\\//g, ''),\n          node;\n\n      if (this.options.loose && value.startsWith(\"//\")) {\n        value = value.substring(2);\n        inline = true;\n      }\n\n      node = new Comment({\n        value: value,\n        inline: inline,\n        source: {\n          start: {\n            line: this.currToken[2],\n            column: this.currToken[3]\n          },\n          end: {\n            line: this.currToken[4],\n            column: this.currToken[5]\n          }\n        },\n        sourceIndex: this.currToken[6]\n      });\n      this.newNode(node);\n      this.position++;\n    }\n  }, {\n    key: \"error\",\n    value: function error(message, token) {\n      throw new ParserError(message + \" at line: \".concat(token[2], \", column \").concat(token[3]));\n    }\n  }, {\n    key: \"loop\",\n    value: function loop() {\n      while (this.position < this.tokens.length) {\n        this.parseTokens();\n      }\n\n      if (!this.current.last && this.spaces) {\n        this.current.raws.before += this.spaces;\n      } else if (this.spaces) {\n        this.current.last.raws.after += this.spaces;\n      }\n\n      this.spaces = '';\n      return this.root;\n    }\n  }, {\n    key: \"operator\",\n    value: function operator() {\n      // if a +|- operator is followed by a non-word character (. is allowed) and\n      // is preceded by a non-word character. (5+5)\n      var char = this.currToken[1],\n          node;\n\n      if (char === '+' || char === '-') {\n        // only inspect if the operator is not the first token, and we're only\n        // within a calc() function: the only spec-valid place for math expressions\n        if (!this.options.loose) {\n          if (this.position > 0) {\n            if (this.current.type === 'func' && this.current.value === 'calc') {\n              // allow operators to be proceeded by spaces and opening parens\n              if (this.prevToken[0] !== 'space' && this.prevToken[0] !== '(') {\n                this.error('Syntax Error', this.currToken);\n              } // valid: calc(1 - +2)\n              // invalid: calc(1 -+2)\n              else if (this.nextToken[0] !== 'space' && this.nextToken[0] !== 'word') {\n                  this.error('Syntax Error', this.currToken);\n                } // valid: calc(1 - +2)\n                // valid: calc(-0.5 + 2)\n                // invalid: calc(1 -2)\n                else if (this.nextToken[0] === 'word' && this.current.last.type !== 'operator' && this.current.last.value !== '(') {\n                    this.error('Syntax Error', this.currToken);\n                  }\n            } // if we're not in a function and someone has doubled up on operators,\n            // or they're trying to perform a calc outside of a calc\n            // eg. +-4px or 5+ 5, throw an error\n            else if (this.nextToken[0] === 'space' || this.nextToken[0] === 'operator' || this.prevToken[0] === 'operator') {\n                this.error('Syntax Error', this.currToken);\n              }\n          }\n        }\n\n        if (!this.options.loose) {\n          if (this.nextToken[0] === 'word') {\n            return this.word();\n          }\n        } else {\n          if ((!this.current.nodes.length || this.current.last && this.current.last.type === 'operator') && this.nextToken[0] === 'word') {\n            return this.word();\n          }\n        }\n      }\n\n      node = new Operator({\n        value: this.currToken[1],\n        source: {\n          start: {\n            line: this.currToken[2],\n            column: this.currToken[3]\n          },\n          end: {\n            line: this.currToken[2],\n            column: this.currToken[3]\n          }\n        },\n        sourceIndex: this.currToken[4]\n      });\n      this.position++;\n      return this.newNode(node);\n    }\n  }, {\n    key: \"parseTokens\",\n    value: function parseTokens() {\n      switch (this.currToken[0]) {\n        case 'space':\n          this.space();\n          break;\n\n        case 'colon':\n          this.colon();\n          break;\n\n        case 'comma':\n          this.comma();\n          break;\n\n        case 'comment':\n          this.comment();\n          break;\n\n        case '(':\n          this.parenOpen();\n          break;\n\n        case ')':\n          this.parenClose();\n          break;\n\n        case 'atword':\n        case 'word':\n          this.word();\n          break;\n\n        case 'operator':\n          this.operator();\n          break;\n\n        case 'string':\n          this.string();\n          break;\n\n        case 'unicoderange':\n          this.unicodeRange();\n          break;\n\n        default:\n          this.word();\n          break;\n      }\n    }\n  }, {\n    key: \"parenOpen\",\n    value: function parenOpen() {\n      var unbalanced = 1,\n          pos = this.position + 1,\n          token = this.currToken,\n          last; // check for balanced parens\n\n      while (pos < this.tokens.length && unbalanced) {\n        var tkn = this.tokens[pos];\n\n        if (tkn[0] === '(') {\n          unbalanced++;\n        }\n\n        if (tkn[0] === ')') {\n          unbalanced--;\n        }\n\n        pos++;\n      }\n\n      if (unbalanced) {\n        this.error('Expected closing parenthesis', token);\n      } // ok, all parens are balanced. continue on\n\n\n      last = this.current.last;\n\n      if (last && last.type === 'func' && last.unbalanced < 0) {\n        last.unbalanced = 0; // ok we're ready to add parens now\n\n        this.current = last;\n      }\n\n      this.current.unbalanced++;\n      this.newNode(new Paren({\n        value: token[1],\n        source: {\n          start: {\n            line: token[2],\n            column: token[3]\n          },\n          end: {\n            line: token[4],\n            column: token[5]\n          }\n        },\n        sourceIndex: token[6]\n      }));\n      this.position++; // url functions get special treatment, and anything between the function\n      // parens get treated as one word, if the contents aren't not a string.\n\n      if (this.current.type === 'func' && this.current.unbalanced && this.current.value === 'url' && this.currToken[0] !== 'string' && this.currToken[0] !== ')' && !this.options.loose) {\n        var nextToken = this.nextToken,\n            value = this.currToken[1],\n            start = {\n          line: this.currToken[2],\n          column: this.currToken[3]\n        };\n\n        while (nextToken && nextToken[0] !== ')' && this.current.unbalanced) {\n          this.position++;\n          value += this.currToken[1];\n          nextToken = this.nextToken;\n        }\n\n        if (this.position !== this.tokens.length - 1) {\n          // skip the following word definition, or it'll be a duplicate\n          this.position++;\n          this.newNode(new Word({\n            value,\n            source: {\n              start,\n              end: {\n                line: this.currToken[4],\n                column: this.currToken[5]\n              }\n            },\n            sourceIndex: this.currToken[6]\n          }));\n        }\n      }\n    }\n  }, {\n    key: \"parenClose\",\n    value: function parenClose() {\n      var token = this.currToken;\n      this.newNode(new Paren({\n        value: token[1],\n        source: {\n          start: {\n            line: token[2],\n            column: token[3]\n          },\n          end: {\n            line: token[4],\n            column: token[5]\n          }\n        },\n        sourceIndex: token[6]\n      }));\n      this.position++;\n\n      if (this.position >= this.tokens.length - 1 && !this.current.unbalanced) {\n        return;\n      }\n\n      this.current.unbalanced--;\n\n      if (this.current.unbalanced < 0) {\n        this.error('Expected opening parenthesis', token);\n      }\n\n      if (!this.current.unbalanced && this.cache.length) {\n        this.current = this.cache.pop();\n      }\n    }\n  }, {\n    key: \"space\",\n    value: function space() {\n      var token = this.currToken; // Handle space before and after the selector\n\n      if (this.position === this.tokens.length - 1 || this.nextToken[0] === ',' || this.nextToken[0] === ')') {\n        this.current.last.raws.after += token[1];\n        this.position++;\n      } else {\n        this.spaces = token[1];\n        this.position++;\n      }\n    }\n  }, {\n    key: \"unicodeRange\",\n    value: function unicodeRange() {\n      var token = this.currToken;\n      this.newNode(new UnicodeRange({\n        value: token[1],\n        source: {\n          start: {\n            line: token[2],\n            column: token[3]\n          },\n          end: {\n            line: token[4],\n            column: token[5]\n          }\n        },\n        sourceIndex: token[6]\n      }));\n      this.position++;\n    }\n  }, {\n    key: \"splitWord\",\n    value: function splitWord() {\n      var _this = this;\n\n      var nextToken = this.nextToken,\n          word = this.currToken[1],\n          rNumber = /^[\\+\\-]?((\\d+(\\.\\d*)?)|(\\.\\d+))([eE][\\+\\-]?\\d+)?/,\n          // treat css-like groupings differently so they can be inspected,\n      // but don't address them as anything but a word, but allow hex values\n      // to pass through.\n      rNoFollow = /^(?!\\#([a-z0-9]+))[\\#\\{\\}]/gi,\n          hasAt,\n          indices;\n\n      if (!rNoFollow.test(word)) {\n        while (nextToken && nextToken[0] === 'word') {\n          this.position++;\n          var current = this.currToken[1];\n          word += current;\n          nextToken = this.nextToken;\n        }\n      }\n\n      hasAt = indexesOf(word, '@');\n      indices = sortAscending(uniq(flatten([[0], hasAt])));\n      indices.forEach(function (ind, i) {\n        var index = indices[i + 1] || word.length,\n            value = word.slice(ind, index),\n            node;\n\n        if (~hasAt.indexOf(ind)) {\n          node = new AtWord({\n            value: value.slice(1),\n            source: {\n              start: {\n                line: _this.currToken[2],\n                column: _this.currToken[3] + ind\n              },\n              end: {\n                line: _this.currToken[4],\n                column: _this.currToken[3] + (index - 1)\n              }\n            },\n            sourceIndex: _this.currToken[6] + indices[i]\n          });\n        } else if (rNumber.test(_this.currToken[1])) {\n          var unit = value.replace(rNumber, '');\n          node = new Numbr({\n            value: value.replace(unit, ''),\n            source: {\n              start: {\n                line: _this.currToken[2],\n                column: _this.currToken[3] + ind\n              },\n              end: {\n                line: _this.currToken[4],\n                column: _this.currToken[3] + (index - 1)\n              }\n            },\n            sourceIndex: _this.currToken[6] + indices[i],\n            unit\n          });\n        } else {\n          node = new (nextToken && nextToken[0] === '(' ? Func : Word)({\n            value,\n            source: {\n              start: {\n                line: _this.currToken[2],\n                column: _this.currToken[3] + ind\n              },\n              end: {\n                line: _this.currToken[4],\n                column: _this.currToken[3] + (index - 1)\n              }\n            },\n            sourceIndex: _this.currToken[6] + indices[i]\n          });\n\n          if (node.constructor.name === 'Word') {\n            node.isHex = /^#(.+)/.test(value);\n            node.isColor = /^#([0-9a-f]{3}|[0-9a-f]{4}|[0-9a-f]{6}|[0-9a-f]{8})$/i.test(value);\n          } else {\n            _this.cache.push(_this.current);\n          }\n        }\n\n        _this.newNode(node);\n      });\n      this.position++;\n    }\n  }, {\n    key: \"string\",\n    value: function string() {\n      var token = this.currToken,\n          value = this.currToken[1],\n          rQuote = /^(\\\"|\\')/,\n          quoted = rQuote.test(value),\n          quote = '',\n          node;\n\n      if (quoted) {\n        quote = value.match(rQuote)[0]; // set value to the string within the quotes\n        // quotes are stored in raws\n\n        value = value.slice(1, value.length - 1);\n      }\n\n      node = new Str({\n        value,\n        source: {\n          start: {\n            line: token[2],\n            column: token[3]\n          },\n          end: {\n            line: token[4],\n            column: token[5]\n          }\n        },\n        sourceIndex: token[6],\n        quoted\n      });\n      node.raws.quote = quote;\n      this.newNode(node);\n      this.position++;\n    }\n  }, {\n    key: \"word\",\n    value: function word() {\n      return this.splitWord();\n    }\n  }, {\n    key: \"newNode\",\n    value: function newNode(node) {\n      if (this.spaces) {\n        node.raws.before += this.spaces;\n        this.spaces = '';\n      }\n\n      return this.current.append(node);\n    }\n  }, {\n    key: \"currToken\",\n    get: function get() {\n      return this.tokens[this.position];\n    }\n  }, {\n    key: \"nextToken\",\n    get: function get() {\n      return this.tokens[this.position + 1];\n    }\n  }, {\n    key: \"prevToken\",\n    get: function get() {\n      return this.tokens[this.position - 1];\n    }\n  }]);\n\n  return Parser;\n}();"},"sourceMaps":null,"error":null,"hash":"d7d1a3010d4623a359418a16ecd72364","cacheData":{"env":{}}}