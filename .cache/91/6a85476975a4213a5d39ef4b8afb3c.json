{"id":"../node_modules/webpack-manifest-plugin/lib/plugin.js","dependencies":[{"name":"/home/jarri/Desktop/lenovo2020/projects-web/eCommerce/template-store1/package.json","includedInParent":true,"mtime":1594655291184},{"name":"/home/jarri/Desktop/lenovo2020/projects-web/eCommerce/template-store1/node_modules/webpack-manifest-plugin/package.json","includedInParent":true,"mtime":1594306881666},{"name":"path","loc":{"line":1,"column":19},"parent":"/home/jarri/Desktop/lenovo2020/projects-web/eCommerce/template-store1/node_modules/webpack-manifest-plugin/lib/plugin.js","resolved":"/home/jarri/Desktop/lenovo2020/projects-web/eCommerce/template-store1/node_modules/path-browserify/index.js"},{"name":"fs-extra","loc":{"line":2,"column":18},"parent":"/home/jarri/Desktop/lenovo2020/projects-web/eCommerce/template-store1/node_modules/webpack-manifest-plugin/lib/plugin.js","resolved":"/home/jarri/Desktop/lenovo2020/projects-web/eCommerce/template-store1/node_modules/fs-extra/lib/index.js"},{"name":"lodash","loc":{"line":3,"column":16},"parent":"/home/jarri/Desktop/lenovo2020/projects-web/eCommerce/template-store1/node_modules/webpack-manifest-plugin/lib/plugin.js","resolved":"/home/jarri/Desktop/lenovo2020/projects-web/eCommerce/template-store1/node_modules/lodash/lodash.js"},{"name":"tapable","loc":{"line":207,"column":38},"parent":"/home/jarri/Desktop/lenovo2020/projects-web/eCommerce/template-store1/node_modules/webpack-manifest-plugin/lib/plugin.js","resolved":"/home/jarri/Desktop/lenovo2020/projects-web/eCommerce/template-store1/node_modules/tapable/lib/index.js"}],"generated":{"js":"var path = require('path');\n\nvar fse = require('fs-extra');\n\nvar _ = require('lodash');\n\nvar emitCountMap = new Map();\n\nfunction ManifestPlugin(opts) {\n  this.opts = _.assign({\n    publicPath: null,\n    basePath: '',\n    fileName: 'manifest.json',\n    transformExtensions: /^(gz|map)$/i,\n    writeToFileEmit: false,\n    seed: null,\n    filter: null,\n    map: null,\n    generate: null,\n    sort: null,\n    serialize: function serialize(manifest) {\n      return JSON.stringify(manifest, null, 2);\n    }\n  }, opts || {});\n}\n\nManifestPlugin.prototype.getFileType = function (str) {\n  str = str.replace(/\\?.*/, '');\n  var split = str.split('.');\n  var ext = split.pop();\n\n  if (this.opts.transformExtensions.test(ext)) {\n    ext = split.pop() + '.' + ext;\n  }\n\n  return ext;\n};\n\nManifestPlugin.prototype.apply = function (compiler) {\n  var moduleAssets = {};\n  var outputFolder = compiler.options.output.path;\n  var outputFile = path.resolve(outputFolder, this.opts.fileName);\n  var outputName = path.relative(outputFolder, outputFile);\n\n  var moduleAsset = function moduleAsset(module, file) {\n    if (module.userRequest) {\n      moduleAssets[file] = path.join(path.dirname(file), path.basename(module.userRequest));\n    }\n  };\n\n  var emit = function (compilation, compileCallback) {\n    var emitCount = emitCountMap.get(outputFile) - 1;\n    emitCountMap.set(outputFile, emitCount);\n    var seed = this.opts.seed || {};\n    var publicPath = this.opts.publicPath != null ? this.opts.publicPath : compilation.options.output.publicPath;\n    var stats = compilation.getStats().toJson();\n    var files = compilation.chunks.reduce(function (files, chunk) {\n      return chunk.files.reduce(function (files, path) {\n        var name = chunk.name ? chunk.name : null;\n\n        if (name) {\n          name = name + '.' + this.getFileType(path);\n        } else {\n          // For nameless chunks, just map the files directly.\n          name = path;\n        } // Webpack 4: .isOnlyInitial()\n        // Webpack 3: .isInitial()\n        // Webpack 1/2: .initial\n\n\n        return files.concat({\n          path: path,\n          chunk: chunk,\n          name: name,\n          isInitial: chunk.isOnlyInitial ? chunk.isOnlyInitial() : chunk.isInitial ? chunk.isInitial() : chunk.initial,\n          isChunk: true,\n          isAsset: false,\n          isModuleAsset: false\n        });\n      }.bind(this), files);\n    }.bind(this), []); // module assets don't show up in assetsByChunkName.\n    // we're getting them this way;\n\n    files = stats.assets.reduce(function (files, asset) {\n      var name = moduleAssets[asset.name];\n\n      if (name) {\n        return files.concat({\n          path: asset.name,\n          name: name,\n          isInitial: false,\n          isChunk: false,\n          isAsset: true,\n          isModuleAsset: true\n        });\n      }\n\n      var isEntryAsset = asset.chunks.length > 0;\n\n      if (isEntryAsset) {\n        return files;\n      }\n\n      return files.concat({\n        path: asset.name,\n        name: asset.name,\n        isInitial: false,\n        isChunk: false,\n        isAsset: true,\n        isModuleAsset: false\n      });\n    }, files);\n    files = files.filter(function (file) {\n      // Don't add hot updates to manifest\n      var isUpdateChunk = file.path.indexOf('hot-update') >= 0; // Don't add manifest from another instance\n\n      var isManifest = emitCountMap.get(path.join(outputFolder, file.name)) !== undefined;\n      return !isUpdateChunk && !isManifest;\n    }); // Append optional basepath onto all references.\n    // This allows output path to be reflected in the manifest.\n\n    if (this.opts.basePath) {\n      files = files.map(function (file) {\n        file.name = this.opts.basePath + file.name;\n        return file;\n      }.bind(this));\n    }\n\n    if (publicPath) {\n      // Similar to basePath but only affects the value (similar to how\n      // output.publicPath turns require('foo/bar') into '/public/foo/bar', see\n      // https://github.com/webpack/docs/wiki/configuration#outputpublicpath\n      files = files.map(function (file) {\n        file.path = publicPath + file.path;\n        return file;\n      }.bind(this));\n    }\n\n    files = files.map(function (file) {\n      file.name = file.name.replace(/\\\\/g, '/');\n      file.path = file.path.replace(/\\\\/g, '/');\n      return file;\n    });\n\n    if (this.opts.filter) {\n      files = files.filter(this.opts.filter);\n    }\n\n    if (this.opts.map) {\n      files = files.map(this.opts.map);\n    }\n\n    if (this.opts.sort) {\n      files = files.sort(this.opts.sort);\n    }\n\n    var manifest;\n\n    if (this.opts.generate) {\n      manifest = this.opts.generate(seed, files);\n    } else {\n      manifest = files.reduce(function (manifest, file) {\n        manifest[file.name] = file.path;\n        return manifest;\n      }, seed);\n    }\n\n    var isLastEmit = emitCount === 0;\n\n    if (isLastEmit) {\n      var output = this.opts.serialize(manifest);\n      compilation.assets[outputName] = {\n        source: function source() {\n          return output;\n        },\n        size: function size() {\n          return output.length;\n        }\n      };\n\n      if (this.opts.writeToFileEmit) {\n        fse.outputFileSync(outputFile, output);\n      }\n    }\n\n    if (compiler.hooks) {\n      compiler.hooks.webpackManifestPluginAfterEmit.call(manifest);\n    } else {\n      compilation.applyPluginsAsync('webpack-manifest-plugin-after-emit', manifest, compileCallback);\n    }\n  }.bind(this);\n\n  function beforeRun(compiler, callback) {\n    var emitCount = emitCountMap.get(outputFile) || 0;\n    emitCountMap.set(outputFile, emitCount + 1);\n\n    if (callback) {\n      callback();\n    }\n  }\n\n  if (compiler.hooks) {\n    var SyncWaterfallHook = require('tapable').SyncWaterfallHook;\n\n    var pluginOptions = {\n      name: 'ManifestPlugin',\n      stage: Infinity\n    };\n    compiler.hooks.webpackManifestPluginAfterEmit = new SyncWaterfallHook(['manifest']);\n    compiler.hooks.compilation.tap(pluginOptions, function (compilation) {\n      compilation.hooks.moduleAsset.tap(pluginOptions, moduleAsset);\n    });\n    compiler.hooks.emit.tap(pluginOptions, emit);\n    compiler.hooks.run.tap(pluginOptions, beforeRun);\n    compiler.hooks.watchRun.tap(pluginOptions, beforeRun);\n  } else {\n    compiler.plugin('compilation', function (compilation) {\n      compilation.plugin('module-asset', moduleAsset);\n    });\n    compiler.plugin('emit', emit);\n    compiler.plugin('before-run', beforeRun);\n    compiler.plugin('watch-run', beforeRun);\n  }\n};\n\nmodule.exports = ManifestPlugin;"},"sourceMaps":null,"error":null,"hash":"69658380702725bb25d983158fd1125f","cacheData":{"env":{}}}