{"id":"../node_modules/webpack/node_modules/chokidar/index.js","dependencies":[{"name":"/home/jarri/Desktop/lenovo2020/projects-web/eCommerce/template-store1/package.json","includedInParent":true,"mtime":1594655165833},{"name":"/home/jarri/Desktop/lenovo2020/projects-web/eCommerce/template-store1/node_modules/webpack/node_modules/chokidar/package.json","includedInParent":true,"mtime":1594578778153},{"name":"events","loc":{"line":3,"column":33},"parent":"/home/jarri/Desktop/lenovo2020/projects-web/eCommerce/template-store1/node_modules/webpack/node_modules/chokidar/index.js","resolved":"/home/jarri/Desktop/lenovo2020/projects-web/eCommerce/template-store1/node_modules/events/events.js"},{"name":"fs","loc":{"line":4,"column":19},"parent":"/home/jarri/Desktop/lenovo2020/projects-web/eCommerce/template-store1/node_modules/webpack/node_modules/chokidar/index.js","resolved":"/home/jarri/Desktop/lenovo2020/projects-web/eCommerce/template-store1/node_modules/parcel-bundler/src/builtins/_empty.js"},{"name":"path","loc":{"line":5,"column":24},"parent":"/home/jarri/Desktop/lenovo2020/projects-web/eCommerce/template-store1/node_modules/webpack/node_modules/chokidar/index.js","resolved":"/home/jarri/Desktop/lenovo2020/projects-web/eCommerce/template-store1/node_modules/path-browserify/index.js"},{"name":"util","loc":{"line":6,"column":30},"parent":"/home/jarri/Desktop/lenovo2020/projects-web/eCommerce/template-store1/node_modules/webpack/node_modules/chokidar/index.js","resolved":"/home/jarri/Desktop/lenovo2020/projects-web/eCommerce/template-store1/node_modules/util/util.js"},{"name":"readdirp","loc":{"line":7,"column":25},"parent":"/home/jarri/Desktop/lenovo2020/projects-web/eCommerce/template-store1/node_modules/webpack/node_modules/chokidar/index.js","resolved":"/home/jarri/Desktop/lenovo2020/projects-web/eCommerce/template-store1/node_modules/webpack/node_modules/readdirp/index.js"},{"name":"anymatch","loc":{"line":8,"column":25},"parent":"/home/jarri/Desktop/lenovo2020/projects-web/eCommerce/template-store1/node_modules/webpack/node_modules/chokidar/index.js","resolved":"/home/jarri/Desktop/lenovo2020/projects-web/eCommerce/template-store1/node_modules/webpack/node_modules/anymatch/index.js"},{"name":"glob-parent","loc":{"line":9,"column":27},"parent":"/home/jarri/Desktop/lenovo2020/projects-web/eCommerce/template-store1/node_modules/webpack/node_modules/chokidar/index.js","resolved":"/home/jarri/Desktop/lenovo2020/projects-web/eCommerce/template-store1/node_modules/webpack/node_modules/glob-parent/index.js"},{"name":"is-glob","loc":{"line":10,"column":23},"parent":"/home/jarri/Desktop/lenovo2020/projects-web/eCommerce/template-store1/node_modules/webpack/node_modules/chokidar/index.js","resolved":"/home/jarri/Desktop/lenovo2020/projects-web/eCommerce/template-store1/node_modules/webpack/node_modules/is-glob/index.js"},{"name":"braces","loc":{"line":11,"column":23},"parent":"/home/jarri/Desktop/lenovo2020/projects-web/eCommerce/template-store1/node_modules/webpack/node_modules/chokidar/index.js","resolved":"/home/jarri/Desktop/lenovo2020/projects-web/eCommerce/template-store1/node_modules/webpack/node_modules/chokidar/node_modules/braces/index.js"},{"name":"normalize-path","loc":{"line":12,"column":30},"parent":"/home/jarri/Desktop/lenovo2020/projects-web/eCommerce/template-store1/node_modules/webpack/node_modules/chokidar/index.js","resolved":"/home/jarri/Desktop/lenovo2020/projects-web/eCommerce/template-store1/node_modules/webpack/node_modules/normalize-path/index.js"},{"name":"./lib/nodefs-handler","loc":{"line":14,"column":30},"parent":"/home/jarri/Desktop/lenovo2020/projects-web/eCommerce/template-store1/node_modules/webpack/node_modules/chokidar/index.js","resolved":"/home/jarri/Desktop/lenovo2020/projects-web/eCommerce/template-store1/node_modules/webpack/node_modules/chokidar/lib/nodefs-handler.js"},{"name":"./lib/fsevents-handler","loc":{"line":15,"column":32},"parent":"/home/jarri/Desktop/lenovo2020/projects-web/eCommerce/template-store1/node_modules/webpack/node_modules/chokidar/index.js","resolved":"/home/jarri/Desktop/lenovo2020/projects-web/eCommerce/template-store1/node_modules/webpack/node_modules/chokidar/lib/fsevents-handler.js"},{"name":"./lib/constants","loc":{"line":51,"column":12},"parent":"/home/jarri/Desktop/lenovo2020/projects-web/eCommerce/template-store1/node_modules/webpack/node_modules/chokidar/index.js","resolved":"/home/jarri/Desktop/lenovo2020/projects-web/eCommerce/template-store1/node_modules/webpack/node_modules/chokidar/lib/constants.js"},{"name":"process","parent":"/home/jarri/Desktop/lenovo2020/projects-web/eCommerce/template-store1/node_modules/webpack/node_modules/chokidar/index.js","resolved":"/home/jarri/Desktop/lenovo2020/projects-web/eCommerce/template-store1/node_modules/process/browser.js"}],"generated":{"js":"var process = require(\"process\");\n'use strict';\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\nfunction _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\n\nfunction _possibleConstructorReturn(self, call) { if (call && (typeof call === \"object\" || typeof call === \"function\")) { return call; } return _assertThisInitialized(self); }\n\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\n\nfunction _isNativeReflectConstruct() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }\n\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\n\nfunction _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }\n\nfunction _nonIterableSpread() { throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _iterableToArray(iter) { if (typeof Symbol !== \"undefined\" && Symbol.iterator in Object(iter)) return Array.from(iter); }\n\nfunction _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nfunction asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }\n\nfunction _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"next\", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"throw\", err); } _next(undefined); }); }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nvar _require = require('events'),\n    EventEmitter = _require.EventEmitter;\n\nvar fs = require('fs');\n\nvar sysPath = require('path');\n\nvar _require2 = require('util'),\n    promisify = _require2.promisify;\n\nvar readdirp = require('readdirp');\n\nvar anymatch = require('anymatch').default;\n\nvar globParent = require('glob-parent');\n\nvar isGlob = require('is-glob');\n\nvar braces = require('braces');\n\nvar normalizePath = require('normalize-path');\n\nvar NodeFsHandler = require('./lib/nodefs-handler');\n\nvar FsEventsHandler = require('./lib/fsevents-handler');\n\nvar _require3 = require('./lib/constants'),\n    EV_ALL = _require3.EV_ALL,\n    EV_READY = _require3.EV_READY,\n    EV_ADD = _require3.EV_ADD,\n    EV_CHANGE = _require3.EV_CHANGE,\n    EV_UNLINK = _require3.EV_UNLINK,\n    EV_ADD_DIR = _require3.EV_ADD_DIR,\n    EV_UNLINK_DIR = _require3.EV_UNLINK_DIR,\n    EV_RAW = _require3.EV_RAW,\n    EV_ERROR = _require3.EV_ERROR,\n    STR_CLOSE = _require3.STR_CLOSE,\n    STR_END = _require3.STR_END,\n    BACK_SLASH_RE = _require3.BACK_SLASH_RE,\n    DOUBLE_SLASH_RE = _require3.DOUBLE_SLASH_RE,\n    SLASH_OR_BACK_SLASH_RE = _require3.SLASH_OR_BACK_SLASH_RE,\n    DOT_RE = _require3.DOT_RE,\n    REPLACER_RE = _require3.REPLACER_RE,\n    SLASH = _require3.SLASH,\n    BRACE_START = _require3.BRACE_START,\n    BANG = _require3.BANG,\n    ONE_DOT = _require3.ONE_DOT,\n    TWO_DOTS = _require3.TWO_DOTS,\n    GLOBSTAR = _require3.GLOBSTAR,\n    SLASH_GLOBSTAR = _require3.SLASH_GLOBSTAR,\n    ANYMATCH_OPTS = _require3.ANYMATCH_OPTS,\n    STRING_TYPE = _require3.STRING_TYPE,\n    FUNCTION_TYPE = _require3.FUNCTION_TYPE,\n    EMPTY_STR = _require3.EMPTY_STR,\n    EMPTY_FN = _require3.EMPTY_FN,\n    isWindows = _require3.isWindows,\n    isMacos = _require3.isMacos;\n\nvar stat = promisify(fs.stat);\nvar readdir = promisify(fs.readdir);\n/**\n * @typedef {String} Path\n * @typedef {'all'|'add'|'addDir'|'change'|'unlink'|'unlinkDir'|'raw'|'error'|'ready'} EventName\n * @typedef {'readdir'|'watch'|'add'|'remove'|'change'} ThrottleType\n */\n\n/**\n *\n * @typedef {Object} WatchHelpers\n * @property {Boolean} followSymlinks\n * @property {'stat'|'lstat'} statMethod\n * @property {Path} path\n * @property {Path} watchPath\n * @property {Function} entryPath\n * @property {Boolean} hasGlob\n * @property {Object} globFilter\n * @property {Function} filterPath\n * @property {Function} filterDir\n */\n\nvar arrify = function arrify() {\n  var value = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\n  return Array.isArray(value) ? value : [value];\n};\n\nvar flatten = function flatten(list) {\n  var result = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n  list.forEach(function (item) {\n    if (Array.isArray(item)) {\n      flatten(item, result);\n    } else {\n      result.push(item);\n    }\n  });\n  return result;\n};\n\nvar unifyPaths = function unifyPaths(paths_) {\n  /**\n   * @type {Array<String>}\n   */\n  var paths = flatten(arrify(paths_));\n\n  if (!paths.every(function (p) {\n    return typeof p === STRING_TYPE;\n  })) {\n    throw new TypeError(\"Non-string provided as watch path: \".concat(paths));\n  }\n\n  return paths.map(normalizePathToUnix);\n};\n\nvar toUnix = function toUnix(string) {\n  var str = string.replace(BACK_SLASH_RE, SLASH);\n\n  while (str.match(DOUBLE_SLASH_RE)) {\n    str = str.replace(DOUBLE_SLASH_RE, SLASH);\n  }\n\n  return str;\n}; // Our version of upath.normalize\n// TODO: this is not equal to path-normalize module - investigate why\n\n\nvar normalizePathToUnix = function normalizePathToUnix(path) {\n  return toUnix(sysPath.normalize(toUnix(path)));\n};\n\nvar normalizeIgnored = function normalizeIgnored() {\n  var cwd = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : EMPTY_STR;\n  return function (path) {\n    if (typeof path !== STRING_TYPE) return path;\n    return normalizePathToUnix(sysPath.isAbsolute(path) ? path : sysPath.join(cwd, path));\n  };\n};\n\nvar getAbsolutePath = function getAbsolutePath(path, cwd) {\n  if (sysPath.isAbsolute(path)) {\n    return path;\n  }\n\n  if (path.startsWith(BANG)) {\n    return BANG + sysPath.join(cwd, path.slice(1));\n  }\n\n  return sysPath.join(cwd, path);\n};\n\nvar undef = function undef(opts, key) {\n  return opts[key] === undefined;\n};\n/**\n * Directory entry.\n * @property {Path} path\n * @property {Set<Path>} items\n */\n\n\nvar DirEntry = /*#__PURE__*/function () {\n  /**\n   * @param {Path} dir\n   * @param {Function} removeWatcher\n   */\n  function DirEntry(dir, removeWatcher) {\n    _classCallCheck(this, DirEntry);\n\n    this.path = dir;\n    this._removeWatcher = removeWatcher;\n    /** @type {Set<Path>} */\n\n    this.items = new Set();\n  }\n\n  _createClass(DirEntry, [{\n    key: \"add\",\n    value: function add(item) {\n      var items = this.items;\n      if (!items) return;\n      if (item !== ONE_DOT && item !== TWO_DOTS) items.add(item);\n    }\n  }, {\n    key: \"remove\",\n    value: function () {\n      var _remove = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee(item) {\n        var items, dir;\n        return regeneratorRuntime.wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                items = this.items;\n\n                if (items) {\n                  _context.next = 3;\n                  break;\n                }\n\n                return _context.abrupt(\"return\");\n\n              case 3:\n                items.delete(item);\n\n                if (!(items.size > 0)) {\n                  _context.next = 6;\n                  break;\n                }\n\n                return _context.abrupt(\"return\");\n\n              case 6:\n                dir = this.path;\n                _context.prev = 7;\n                _context.next = 10;\n                return readdir(dir);\n\n              case 10:\n                _context.next = 15;\n                break;\n\n              case 12:\n                _context.prev = 12;\n                _context.t0 = _context[\"catch\"](7);\n\n                if (this._removeWatcher) {\n                  this._removeWatcher(sysPath.dirname(dir), sysPath.basename(dir));\n                }\n\n              case 15:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee, this, [[7, 12]]);\n      }));\n\n      function remove(_x) {\n        return _remove.apply(this, arguments);\n      }\n\n      return remove;\n    }()\n  }, {\n    key: \"has\",\n    value: function has(item) {\n      var items = this.items;\n      if (!items) return;\n      return items.has(item);\n    }\n    /**\n     * @returns {Array<String>}\n     */\n\n  }, {\n    key: \"getChildren\",\n    value: function getChildren() {\n      var items = this.items;\n      if (!items) return;\n      return _toConsumableArray(items.values());\n    }\n  }, {\n    key: \"dispose\",\n    value: function dispose() {\n      this.items.clear();\n      delete this.path;\n      delete this._removeWatcher;\n      delete this.items;\n      Object.freeze(this);\n    }\n  }]);\n\n  return DirEntry;\n}();\n\nvar STAT_METHOD_F = 'stat';\nvar STAT_METHOD_L = 'lstat';\n\nvar WatchHelper = /*#__PURE__*/function () {\n  function WatchHelper(path, watchPath, follow, fsw) {\n    _classCallCheck(this, WatchHelper);\n\n    this.fsw = fsw;\n    this.path = path = path.replace(REPLACER_RE, EMPTY_STR);\n    this.watchPath = watchPath;\n    this.fullWatchPath = sysPath.resolve(watchPath);\n    this.hasGlob = watchPath !== path;\n    /** @type {object|boolean} */\n\n    if (path === EMPTY_STR) this.hasGlob = false;\n    this.globSymlink = this.hasGlob && follow ? undefined : false;\n    this.globFilter = this.hasGlob ? anymatch(path, undefined, ANYMATCH_OPTS) : false;\n    this.dirParts = this.getDirParts(path);\n    this.dirParts.forEach(function (parts) {\n      if (parts.length > 1) parts.pop();\n    });\n    this.followSymlinks = follow;\n    this.statMethod = follow ? STAT_METHOD_F : STAT_METHOD_L;\n  }\n\n  _createClass(WatchHelper, [{\n    key: \"checkGlobSymlink\",\n    value: function checkGlobSymlink(entry) {\n      // only need to resolve once\n      // first entry should always have entry.parentDir === EMPTY_STR\n      if (this.globSymlink === undefined) {\n        this.globSymlink = entry.fullParentDir === this.fullWatchPath ? false : {\n          realPath: entry.fullParentDir,\n          linkPath: this.fullWatchPath\n        };\n      }\n\n      if (this.globSymlink) {\n        return entry.fullPath.replace(this.globSymlink.realPath, this.globSymlink.linkPath);\n      }\n\n      return entry.fullPath;\n    }\n  }, {\n    key: \"entryPath\",\n    value: function entryPath(entry) {\n      return sysPath.join(this.watchPath, sysPath.relative(this.watchPath, this.checkGlobSymlink(entry)));\n    }\n  }, {\n    key: \"filterPath\",\n    value: function filterPath(entry) {\n      var stats = entry.stats;\n      if (stats && stats.isSymbolicLink()) return this.filterDir(entry);\n      var resolvedPath = this.entryPath(entry);\n      var matchesGlob = this.hasGlob && typeof this.globFilter === FUNCTION_TYPE ? this.globFilter(resolvedPath) : true;\n      return matchesGlob && this.fsw._isntIgnored(resolvedPath, stats) && this.fsw._hasReadPermissions(stats);\n    }\n  }, {\n    key: \"getDirParts\",\n    value: function getDirParts(path) {\n      var _this = this;\n\n      if (!this.hasGlob) return [];\n      var parts = [];\n      var expandedPath = path.includes(BRACE_START) ? braces.expand(path) : [path];\n      expandedPath.forEach(function (path) {\n        parts.push(sysPath.relative(_this.watchPath, path).split(SLASH_OR_BACK_SLASH_RE));\n      });\n      return parts;\n    }\n  }, {\n    key: \"filterDir\",\n    value: function filterDir(entry) {\n      if (this.hasGlob) {\n        var entryParts = this.getDirParts(this.checkGlobSymlink(entry));\n        var globstar = false;\n        this.unmatchedGlob = !this.dirParts.some(function (parts) {\n          return parts.every(function (part, i) {\n            if (part === GLOBSTAR) globstar = true;\n            return globstar || !entryParts[0][i] || anymatch(part, entryParts[0][i], ANYMATCH_OPTS);\n          });\n        });\n      }\n\n      return !this.unmatchedGlob && this.fsw._isntIgnored(this.entryPath(entry), entry.stats);\n    }\n  }]);\n\n  return WatchHelper;\n}();\n/**\n * Watches files & directories for changes. Emitted events:\n * `add`, `addDir`, `change`, `unlink`, `unlinkDir`, `all`, `error`\n *\n *     new FSWatcher()\n *       .add(directories)\n *       .on('add', path => log('File', path, 'was added'))\n */\n\n\nvar FSWatcher = /*#__PURE__*/function (_EventEmitter) {\n  _inherits(FSWatcher, _EventEmitter);\n\n  var _super = _createSuper(FSWatcher);\n\n  // Not indenting methods for history sake; for now.\n  function FSWatcher(_opts) {\n    var _this2;\n\n    _classCallCheck(this, FSWatcher);\n\n    _this2 = _super.call(this);\n    var opts = {};\n    if (_opts) Object.assign(opts, _opts); // for frozen objects\n\n    /** @type {Map<String, DirEntry>} */\n\n    _this2._watched = new Map();\n    /** @type {Map<String, Array>} */\n\n    _this2._closers = new Map();\n    /** @type {Set<String>} */\n\n    _this2._ignoredPaths = new Set();\n    /** @type {Map<ThrottleType, Map>} */\n\n    _this2._throttled = new Map();\n    /** @type {Map<Path, String|Boolean>} */\n\n    _this2._symlinkPaths = new Map();\n    _this2._streams = new Set();\n    _this2.closed = false; // Set up default options.\n\n    if (undef(opts, 'persistent')) opts.persistent = true;\n    if (undef(opts, 'ignoreInitial')) opts.ignoreInitial = false;\n    if (undef(opts, 'ignorePermissionErrors')) opts.ignorePermissionErrors = false;\n    if (undef(opts, 'interval')) opts.interval = 100;\n    if (undef(opts, 'binaryInterval')) opts.binaryInterval = 300;\n    if (undef(opts, 'disableGlobbing')) opts.disableGlobbing = false;\n    opts.enableBinaryInterval = opts.binaryInterval !== opts.interval; // Enable fsevents on OS X when polling isn't explicitly enabled.\n\n    if (undef(opts, 'useFsEvents')) opts.useFsEvents = !opts.usePolling; // If we can't use fsevents, ensure the options reflect it's disabled.\n\n    var canUseFsEvents = FsEventsHandler.canUse();\n    if (!canUseFsEvents) opts.useFsEvents = false; // Use polling on Mac if not using fsevents.\n    // Other platforms use non-polling fs_watch.\n\n    if (undef(opts, 'usePolling') && !opts.useFsEvents) {\n      opts.usePolling = isMacos;\n    } // Global override (useful for end-developers that need to force polling for all\n    // instances of chokidar, regardless of usage/dependency depth)\n\n\n    var envPoll = undefined;\n\n    if (envPoll !== undefined) {\n      var envLower = envPoll.toLowerCase();\n\n      if (envLower === 'false' || envLower === '0') {\n        opts.usePolling = false;\n      } else if (envLower === 'true' || envLower === '1') {\n        opts.usePolling = true;\n      } else {\n        opts.usePolling = !!envLower;\n      }\n    }\n\n    var envInterval = undefined;\n\n    if (envInterval) {\n      opts.interval = Number.parseInt(envInterval, 10);\n    } // Editor atomic write normalization enabled by default with fs.watch\n\n\n    if (undef(opts, 'atomic')) opts.atomic = !opts.usePolling && !opts.useFsEvents;\n    if (opts.atomic) _this2._pendingUnlinks = new Map();\n    if (undef(opts, 'followSymlinks')) opts.followSymlinks = true;\n    if (undef(opts, 'awaitWriteFinish')) opts.awaitWriteFinish = false;\n    if (opts.awaitWriteFinish === true) opts.awaitWriteFinish = {};\n    var awf = opts.awaitWriteFinish;\n\n    if (awf) {\n      if (!awf.stabilityThreshold) awf.stabilityThreshold = 2000;\n      if (!awf.pollInterval) awf.pollInterval = 100;\n      _this2._pendingWrites = new Map();\n    }\n\n    if (opts.ignored) opts.ignored = arrify(opts.ignored);\n    var readyCalls = 0;\n\n    _this2._emitReady = function () {\n      readyCalls++;\n\n      if (readyCalls >= _this2._readyCount) {\n        _this2._emitReady = EMPTY_FN;\n        _this2._readyEmitted = true; // use process.nextTick to allow time for listener to be bound\n\n        process.nextTick(function () {\n          return _this2.emit(EV_READY);\n        });\n      }\n    };\n\n    _this2._emitRaw = function () {\n      var _this3;\n\n      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n        args[_key] = arguments[_key];\n      }\n\n      return (_this3 = _this2).emit.apply(_this3, [EV_RAW].concat(args));\n    };\n\n    _this2._readyEmitted = false;\n    _this2.options = opts; // Initialize with proper watcher.\n\n    if (opts.useFsEvents) {\n      _this2._fsEventsHandler = new FsEventsHandler(_assertThisInitialized(_this2));\n    } else {\n      _this2._nodeFsHandler = new NodeFsHandler(_assertThisInitialized(_this2));\n    } // You’re frozen when your heart’s not open.\n\n\n    Object.freeze(opts);\n    return _this2;\n  } // Public methods\n\n  /**\n   * Adds paths to be watched on an existing FSWatcher instance\n   * @param {Path|Array<Path>} paths_\n   * @param {String=} _origAdd private; for handling non-existent paths to be watched\n   * @param {Boolean=} _internal private; indicates a non-user add\n   * @returns {FSWatcher} for chaining\n   */\n\n\n  _createClass(FSWatcher, [{\n    key: \"add\",\n    value: function add(paths_, _origAdd, _internal) {\n      var _this4 = this;\n\n      var _this$options = this.options,\n          cwd = _this$options.cwd,\n          disableGlobbing = _this$options.disableGlobbing;\n      this.closed = false;\n      var paths = unifyPaths(paths_);\n\n      if (cwd) {\n        paths = paths.map(function (path) {\n          var absPath = getAbsolutePath(path, cwd); // Check `path` instead of `absPath` because the cwd portion can't be a glob\n\n          if (disableGlobbing || !isGlob(path)) {\n            return absPath;\n          }\n\n          return normalizePath(absPath);\n        });\n      } // set aside negated glob strings\n\n\n      paths = paths.filter(function (path) {\n        if (path.startsWith(BANG)) {\n          _this4._ignoredPaths.add(path.slice(1));\n\n          return false;\n        } // if a path is being added that was previously ignored, stop ignoring it\n\n\n        _this4._ignoredPaths.delete(path);\n\n        _this4._ignoredPaths.delete(path + SLASH_GLOBSTAR); // reset the cached userIgnored anymatch fn\n        // to make ignoredPaths changes effective\n\n\n        _this4._userIgnored = undefined;\n        return true;\n      });\n\n      if (this.options.useFsEvents && this._fsEventsHandler) {\n        if (!this._readyCount) this._readyCount = paths.length;\n        if (this.options.persistent) this._readyCount *= 2;\n        paths.forEach(function (path) {\n          return _this4._fsEventsHandler._addToFsEvents(path);\n        });\n      } else {\n        if (!this._readyCount) this._readyCount = 0;\n        this._readyCount += paths.length;\n        Promise.all(paths.map( /*#__PURE__*/function () {\n          var _ref = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee2(path) {\n            var res;\n            return regeneratorRuntime.wrap(function _callee2$(_context2) {\n              while (1) {\n                switch (_context2.prev = _context2.next) {\n                  case 0:\n                    _context2.next = 2;\n                    return _this4._nodeFsHandler._addToNodeFs(path, !_internal, 0, 0, _origAdd);\n\n                  case 2:\n                    res = _context2.sent;\n                    if (res) _this4._emitReady();\n                    return _context2.abrupt(\"return\", res);\n\n                  case 5:\n                  case \"end\":\n                    return _context2.stop();\n                }\n              }\n            }, _callee2);\n          }));\n\n          return function (_x2) {\n            return _ref.apply(this, arguments);\n          };\n        }())).then(function (results) {\n          if (_this4.closed) return;\n          results.filter(function (item) {\n            return item;\n          }).forEach(function (item) {\n            _this4.add(sysPath.dirname(item), sysPath.basename(_origAdd || item));\n          });\n        });\n      }\n\n      return this;\n    }\n    /**\n     * Close watchers or start ignoring events from specified paths.\n     * @param {Path|Array<Path>} paths_ - string or array of strings, file/directory paths and/or globs\n     * @returns {FSWatcher} for chaining\n    */\n\n  }, {\n    key: \"unwatch\",\n    value: function unwatch(paths_) {\n      var _this5 = this;\n\n      if (this.closed) return this;\n      var paths = unifyPaths(paths_);\n      var cwd = this.options.cwd;\n      paths.forEach(function (path) {\n        // convert to absolute path unless relative path already matches\n        if (!sysPath.isAbsolute(path) && !_this5._closers.has(path)) {\n          if (cwd) path = sysPath.join(cwd, path);\n          path = sysPath.resolve(path);\n        }\n\n        _this5._closePath(path);\n\n        _this5._ignoredPaths.add(path);\n\n        if (_this5._watched.has(path)) {\n          _this5._ignoredPaths.add(path + SLASH_GLOBSTAR);\n        } // reset the cached userIgnored anymatch fn\n        // to make ignoredPaths changes effective\n\n\n        _this5._userIgnored = undefined;\n      });\n      return this;\n    }\n    /**\n     * Close watchers and remove all listeners from watched paths.\n     * @returns {Promise<void>}.\n    */\n\n  }, {\n    key: \"close\",\n    value: function close() {\n      var _this6 = this;\n\n      if (this.closed) return this._closePromise;\n      this.closed = true; // Memory management.\n\n      this.removeAllListeners();\n      var closers = [];\n\n      this._closers.forEach(function (closerList) {\n        return closerList.forEach(function (closer) {\n          var promise = closer();\n          if (promise instanceof Promise) closers.push(promise);\n        });\n      });\n\n      this._streams.forEach(function (stream) {\n        return stream.destroy();\n      });\n\n      this._userIgnored = undefined;\n      this._readyCount = 0;\n      this._readyEmitted = false;\n\n      this._watched.forEach(function (dirent) {\n        return dirent.dispose();\n      });\n\n      ['closers', 'watched', 'streams', 'symlinkPaths', 'throttled'].forEach(function (key) {\n        _this6[\"_\".concat(key)].clear();\n      });\n      this._closePromise = closers.length ? Promise.all(closers).then(function () {\n        return undefined;\n      }) : Promise.resolve();\n      return this._closePromise;\n    }\n    /**\n     * Expose list of watched paths\n     * @returns {Object} for chaining\n    */\n\n  }, {\n    key: \"getWatched\",\n    value: function getWatched() {\n      var _this7 = this;\n\n      var watchList = {};\n\n      this._watched.forEach(function (entry, dir) {\n        var key = _this7.options.cwd ? sysPath.relative(_this7.options.cwd, dir) : dir;\n        watchList[key || ONE_DOT] = entry.getChildren().sort();\n      });\n\n      return watchList;\n    }\n  }, {\n    key: \"emitWithAll\",\n    value: function emitWithAll(event, args) {\n      this.emit.apply(this, _toConsumableArray(args));\n      if (event !== EV_ERROR) this.emit.apply(this, [EV_ALL].concat(_toConsumableArray(args)));\n    } // Common helpers\n    // --------------\n\n    /**\n     * Normalize and emit events.\n     * Calling _emit DOES NOT MEAN emit() would be called!\n     * @param {EventName} event Type of event\n     * @param {Path} path File or directory path\n     * @param {*=} val1 arguments to be passed with event\n     * @param {*=} val2\n     * @param {*=} val3\n     * @returns the error if defined, otherwise the value of the FSWatcher instance's `closed` flag\n     */\n\n  }, {\n    key: \"_emit\",\n    value: function () {\n      var _emit2 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee3(event, path, val1, val2, val3) {\n        var _this8 = this;\n\n        var opts, args, awf, pw, awfEmit, isThrottled, fullPath, stats;\n        return regeneratorRuntime.wrap(function _callee3$(_context3) {\n          while (1) {\n            switch (_context3.prev = _context3.next) {\n              case 0:\n                if (!this.closed) {\n                  _context3.next = 2;\n                  break;\n                }\n\n                return _context3.abrupt(\"return\");\n\n              case 2:\n                opts = this.options;\n                if (isWindows) path = sysPath.normalize(path);\n                if (opts.cwd) path = sysPath.relative(opts.cwd, path);\n                /** @type Array<any> */\n\n                args = [event, path];\n                if (val3 !== undefined) args.push(val1, val2, val3);else if (val2 !== undefined) args.push(val1, val2);else if (val1 !== undefined) args.push(val1);\n                awf = opts.awaitWriteFinish;\n\n                if (!(awf && (pw = this._pendingWrites.get(path)))) {\n                  _context3.next = 11;\n                  break;\n                }\n\n                pw.lastChange = new Date();\n                return _context3.abrupt(\"return\", this);\n\n              case 11:\n                if (!opts.atomic) {\n                  _context3.next = 17;\n                  break;\n                }\n\n                if (!(event === EV_UNLINK)) {\n                  _context3.next = 16;\n                  break;\n                }\n\n                this._pendingUnlinks.set(path, args);\n\n                setTimeout(function () {\n                  _this8._pendingUnlinks.forEach(function (entry, path) {\n                    _this8.emit.apply(_this8, _toConsumableArray(entry));\n\n                    _this8.emit.apply(_this8, [EV_ALL].concat(_toConsumableArray(entry)));\n\n                    _this8._pendingUnlinks.delete(path);\n                  });\n                }, typeof opts.atomic === 'number' ? opts.atomic : 100);\n                return _context3.abrupt(\"return\", this);\n\n              case 16:\n                if (event === EV_ADD && this._pendingUnlinks.has(path)) {\n                  event = args[0] = EV_CHANGE;\n\n                  this._pendingUnlinks.delete(path);\n                }\n\n              case 17:\n                if (!(awf && (event === EV_ADD || event === EV_CHANGE) && this._readyEmitted)) {\n                  _context3.next = 21;\n                  break;\n                }\n\n                awfEmit = function awfEmit(err, stats) {\n                  if (err) {\n                    event = args[0] = EV_ERROR;\n                    args[1] = err;\n\n                    _this8.emitWithAll(event, args);\n                  } else if (stats) {\n                    // if stats doesn't exist the file must have been deleted\n                    if (args.length > 2) {\n                      args[2] = stats;\n                    } else {\n                      args.push(stats);\n                    }\n\n                    _this8.emitWithAll(event, args);\n                  }\n                };\n\n                this._awaitWriteFinish(path, awf.stabilityThreshold, event, awfEmit);\n\n                return _context3.abrupt(\"return\", this);\n\n              case 21:\n                if (!(event === EV_CHANGE)) {\n                  _context3.next = 25;\n                  break;\n                }\n\n                isThrottled = !this._throttle(EV_CHANGE, path, 50);\n\n                if (!isThrottled) {\n                  _context3.next = 25;\n                  break;\n                }\n\n                return _context3.abrupt(\"return\", this);\n\n              case 25:\n                if (!(opts.alwaysStat && val1 === undefined && (event === EV_ADD || event === EV_ADD_DIR || event === EV_CHANGE))) {\n                  _context3.next = 38;\n                  break;\n                }\n\n                fullPath = opts.cwd ? sysPath.join(opts.cwd, path) : path;\n                _context3.prev = 27;\n                _context3.next = 30;\n                return stat(fullPath);\n\n              case 30:\n                stats = _context3.sent;\n                _context3.next = 35;\n                break;\n\n              case 33:\n                _context3.prev = 33;\n                _context3.t0 = _context3[\"catch\"](27);\n\n              case 35:\n                if (!(!stats || this.closed)) {\n                  _context3.next = 37;\n                  break;\n                }\n\n                return _context3.abrupt(\"return\");\n\n              case 37:\n                args.push(stats);\n\n              case 38:\n                this.emitWithAll(event, args);\n                return _context3.abrupt(\"return\", this);\n\n              case 40:\n              case \"end\":\n                return _context3.stop();\n            }\n          }\n        }, _callee3, this, [[27, 33]]);\n      }));\n\n      function _emit(_x3, _x4, _x5, _x6, _x7) {\n        return _emit2.apply(this, arguments);\n      }\n\n      return _emit;\n    }()\n    /**\n     * Common handler for errors\n     * @param {Error} error\n     * @returns {Error|Boolean} The error if defined, otherwise the value of the FSWatcher instance's `closed` flag\n     */\n\n  }, {\n    key: \"_handleError\",\n    value: function _handleError(error) {\n      var code = error && error.code;\n\n      if (error && code !== 'ENOENT' && code !== 'ENOTDIR' && (!this.options.ignorePermissionErrors || code !== 'EPERM' && code !== 'EACCES')) {\n        this.emit(EV_ERROR, error);\n      }\n\n      return error || this.closed;\n    }\n    /**\n     * Helper utility for throttling\n     * @param {ThrottleType} actionType type being throttled\n     * @param {Path} path being acted upon\n     * @param {Number} timeout duration of time to suppress duplicate actions\n     * @returns {Object|false} tracking object or false if action should be suppressed\n     */\n\n  }, {\n    key: \"_throttle\",\n    value: function _throttle(actionType, path, timeout) {\n      if (!this._throttled.has(actionType)) {\n        this._throttled.set(actionType, new Map());\n      }\n      /** @type {Map<Path, Object>} */\n\n\n      var action = this._throttled.get(actionType);\n      /** @type {Object} */\n\n\n      var actionPath = action.get(path);\n\n      if (actionPath) {\n        actionPath.count++;\n        return false;\n      }\n\n      var timeoutObject;\n\n      var clear = function clear() {\n        var item = action.get(path);\n        var count = item ? item.count : 0;\n        action.delete(path);\n        clearTimeout(timeoutObject);\n        if (item) clearTimeout(item.timeoutObject);\n        return count;\n      };\n\n      timeoutObject = setTimeout(clear, timeout);\n      var thr = {\n        timeoutObject,\n        clear,\n        count: 0\n      };\n      action.set(path, thr);\n      return thr;\n    }\n  }, {\n    key: \"_incrReadyCount\",\n    value: function _incrReadyCount() {\n      return this._readyCount++;\n    }\n    /**\n     * Awaits write operation to finish.\n     * Polls a newly created file for size variations. When files size does not change for 'threshold' milliseconds calls callback.\n     * @param {Path} path being acted upon\n     * @param {Number} threshold Time in milliseconds a file size must be fixed before acknowledging write OP is finished\n     * @param {EventName} event\n     * @param {Function} awfEmit Callback to be called when ready for event to be emitted.\n     */\n\n  }, {\n    key: \"_awaitWriteFinish\",\n    value: function _awaitWriteFinish(path, threshold, event, awfEmit) {\n      var _this9 = this;\n\n      var timeoutHandler;\n      var fullPath = path;\n\n      if (this.options.cwd && !sysPath.isAbsolute(path)) {\n        fullPath = sysPath.join(this.options.cwd, path);\n      }\n\n      var now = new Date();\n\n      var awaitWriteFinish = function awaitWriteFinish(prevStat) {\n        fs.stat(fullPath, function (err, curStat) {\n          if (err || !_this9._pendingWrites.has(path)) {\n            if (err && err.code !== 'ENOENT') awfEmit(err);\n            return;\n          }\n\n          var now = Number(new Date());\n\n          if (prevStat && curStat.size !== prevStat.size) {\n            _this9._pendingWrites.get(path).lastChange = now;\n          }\n\n          var pw = _this9._pendingWrites.get(path);\n\n          var df = now - pw.lastChange;\n\n          if (df >= threshold) {\n            _this9._pendingWrites.delete(path);\n\n            awfEmit(undefined, curStat);\n          } else {\n            timeoutHandler = setTimeout(awaitWriteFinish, _this9.options.awaitWriteFinish.pollInterval, curStat);\n          }\n        });\n      };\n\n      if (!this._pendingWrites.has(path)) {\n        this._pendingWrites.set(path, {\n          lastChange: now,\n          cancelWait: function cancelWait() {\n            _this9._pendingWrites.delete(path);\n\n            clearTimeout(timeoutHandler);\n            return event;\n          }\n        });\n\n        timeoutHandler = setTimeout(awaitWriteFinish, this.options.awaitWriteFinish.pollInterval);\n      }\n    }\n  }, {\n    key: \"_getGlobIgnored\",\n    value: function _getGlobIgnored() {\n      return _toConsumableArray(this._ignoredPaths.values());\n    }\n    /**\n     * Determines whether user has asked to ignore this path.\n     * @param {Path} path filepath or dir\n     * @param {fs.Stats=} stats result of fs.stat\n     * @returns {Boolean}\n     */\n\n  }, {\n    key: \"_isIgnored\",\n    value: function _isIgnored(path, stats) {\n      if (this.options.atomic && DOT_RE.test(path)) return true;\n\n      if (!this._userIgnored) {\n        var cwd = this.options.cwd;\n        var ign = this.options.ignored;\n        var ignored = ign && ign.map(normalizeIgnored(cwd));\n        var paths = arrify(ignored).filter(function (path) {\n          return typeof path === STRING_TYPE && !isGlob(path);\n        }).map(function (path) {\n          return path + SLASH_GLOBSTAR;\n        });\n\n        var list = this._getGlobIgnored().map(normalizeIgnored(cwd)).concat(ignored, paths);\n\n        this._userIgnored = anymatch(list, undefined, ANYMATCH_OPTS);\n      }\n\n      return this._userIgnored([path, stats]);\n    }\n  }, {\n    key: \"_isntIgnored\",\n    value: function _isntIgnored(path, stat) {\n      return !this._isIgnored(path, stat);\n    }\n    /**\n     * Provides a set of common helpers and properties relating to symlink and glob handling.\n     * @param {Path} path file, directory, or glob pattern being watched\n     * @param {Number=} depth at any depth > 0, this isn't a glob\n     * @returns {WatchHelper} object containing helpers for this path\n     */\n\n  }, {\n    key: \"_getWatchHelpers\",\n    value: function _getWatchHelpers(path, depth) {\n      var watchPath = depth || this.options.disableGlobbing || !isGlob(path) ? path : globParent(path);\n      var follow = this.options.followSymlinks;\n      return new WatchHelper(path, watchPath, follow, this);\n    } // Directory helpers\n    // -----------------\n\n    /**\n     * Provides directory tracking objects\n     * @param {String} directory path of the directory\n     * @returns {DirEntry} the directory's tracking object\n     */\n\n  }, {\n    key: \"_getWatchedDir\",\n    value: function _getWatchedDir(directory) {\n      if (!this._boundRemove) this._boundRemove = this._remove.bind(this);\n      var dir = sysPath.resolve(directory);\n      if (!this._watched.has(dir)) this._watched.set(dir, new DirEntry(dir, this._boundRemove));\n      return this._watched.get(dir);\n    } // File helpers\n    // ------------\n\n    /**\n     * Check for read permissions.\n     * Based on this answer on SO: https://stackoverflow.com/a/11781404/1358405\n     * @param {fs.Stats} stats - object, result of fs_stat\n     * @returns {Boolean} indicates whether the file can be read\n    */\n\n  }, {\n    key: \"_hasReadPermissions\",\n    value: function _hasReadPermissions(stats) {\n      if (this.options.ignorePermissionErrors) return true; // stats.mode may be bigint\n\n      var md = stats && Number.parseInt(stats.mode, 10);\n      var st = md & 0o777;\n      var it = Number.parseInt(st.toString(8)[0], 10);\n      return Boolean(4 & it);\n    }\n    /**\n     * Handles emitting unlink events for\n     * files and directories, and via recursion, for\n     * files and directories within directories that are unlinked\n     * @param {String} directory within which the following item is located\n     * @param {String} item      base path of item/directory\n     * @returns {void}\n    */\n\n  }, {\n    key: \"_remove\",\n    value: function _remove(directory, item, isDirectory) {\n      var _this10 = this;\n\n      // if what is being deleted is a directory, get that directory's paths\n      // for recursive deleting and cleaning of watched object\n      // if it is not a directory, nestedDirectoryChildren will be empty array\n      var path = sysPath.join(directory, item);\n      var fullPath = sysPath.resolve(path);\n      isDirectory = isDirectory != null ? isDirectory : this._watched.has(path) || this._watched.has(fullPath); // prevent duplicate handling in case of arriving here nearly simultaneously\n      // via multiple paths (such as _handleFile and _handleDir)\n\n      if (!this._throttle('remove', path, 100)) return; // if the only watched file is removed, watch for its return\n\n      if (!isDirectory && !this.options.useFsEvents && this._watched.size === 1) {\n        this.add(directory, item, true);\n      } // This will create a new entry in the watched object in either case\n      // so we got to do the directory check beforehand\n\n\n      var wp = this._getWatchedDir(path);\n\n      var nestedDirectoryChildren = wp.getChildren(); // Recursively remove children directories / files.\n\n      nestedDirectoryChildren.forEach(function (nested) {\n        return _this10._remove(path, nested);\n      }); // Check if item was on the watched list and remove it\n\n      var parent = this._getWatchedDir(directory);\n\n      var wasTracked = parent.has(item);\n      parent.remove(item); // If we wait for this file to be fully written, cancel the wait.\n\n      var relPath = path;\n      if (this.options.cwd) relPath = sysPath.relative(this.options.cwd, path);\n\n      if (this.options.awaitWriteFinish && this._pendingWrites.has(relPath)) {\n        var event = this._pendingWrites.get(relPath).cancelWait();\n\n        if (event === EV_ADD) return;\n      } // The Entry will either be a directory that just got removed\n      // or a bogus entry to a file, in either case we have to remove it\n\n\n      this._watched.delete(path);\n\n      this._watched.delete(fullPath);\n\n      var eventName = isDirectory ? EV_UNLINK_DIR : EV_UNLINK;\n      if (wasTracked && !this._isIgnored(path)) this._emit(eventName, path); // Avoid conflicts if we later create another file with the same name\n\n      if (!this.options.useFsEvents) {\n        this._closePath(path);\n      }\n    }\n    /**\n     *\n     * @param {Path} path\n     */\n\n  }, {\n    key: \"_closePath\",\n    value: function _closePath(path) {\n      var closers = this._closers.get(path);\n\n      if (!closers) return;\n      closers.forEach(function (closer) {\n        return closer();\n      });\n\n      this._closers.delete(path);\n\n      var dir = sysPath.dirname(path);\n\n      this._getWatchedDir(dir).remove(sysPath.basename(path));\n    }\n    /**\n     *\n     * @param {Path} path\n     * @param {Function} closer\n     */\n\n  }, {\n    key: \"_addPathCloser\",\n    value: function _addPathCloser(path, closer) {\n      if (!closer) return;\n\n      var list = this._closers.get(path);\n\n      if (!list) {\n        list = [];\n\n        this._closers.set(path, list);\n      }\n\n      list.push(closer);\n    }\n  }, {\n    key: \"_readdirp\",\n    value: function _readdirp(root, opts) {\n      var _this11 = this;\n\n      if (this.closed) return;\n\n      var options = _objectSpread({\n        type: EV_ALL,\n        alwaysStat: true,\n        lstat: true\n      }, opts);\n\n      var stream = readdirp(root, options);\n\n      this._streams.add(stream);\n\n      stream.once(STR_CLOSE, function () {\n        stream = undefined;\n      });\n      stream.once(STR_END, function () {\n        if (stream) {\n          _this11._streams.delete(stream);\n\n          stream = undefined;\n        }\n      });\n      return stream;\n    }\n  }]);\n\n  return FSWatcher;\n}(EventEmitter); // Export FSWatcher class\n\n\nexports.FSWatcher = FSWatcher;\n/**\n * Instantiates watcher with paths to be tracked.\n * @param {String|Array<String>} paths file/directory paths and/or globs\n * @param {Object=} options chokidar opts\n * @returns an instance of FSWatcher for chaining.\n */\n\nvar watch = function watch(paths, options) {\n  var watcher = new FSWatcher(options);\n  watcher.add(paths);\n  return watcher;\n};\n\nexports.watch = watch;"},"sourceMaps":null,"error":null,"hash":"2e57881bb05ea3371bf5c68da208c915","cacheData":{"env":{}}}