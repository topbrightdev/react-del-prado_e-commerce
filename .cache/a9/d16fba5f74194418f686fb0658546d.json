{"id":"../node_modules/autoprefixer/lib/selector.js","dependencies":[{"name":"/home/jarri/Desktop/lenovo2020/projects-web/eCommerce/template-store1/package.json","includedInParent":true,"mtime":1594655165833},{"name":"/home/jarri/Desktop/lenovo2020/projects-web/eCommerce/template-store1/node_modules/autoprefixer/package.json","includedInParent":true,"mtime":1594570878686},{"name":"./old-selector","loc":{"line":7,"column":26},"parent":"/home/jarri/Desktop/lenovo2020/projects-web/eCommerce/template-store1/node_modules/autoprefixer/lib/selector.js","resolved":"/home/jarri/Desktop/lenovo2020/projects-web/eCommerce/template-store1/node_modules/autoprefixer/lib/old-selector.js"},{"name":"./prefixer","loc":{"line":9,"column":23},"parent":"/home/jarri/Desktop/lenovo2020/projects-web/eCommerce/template-store1/node_modules/autoprefixer/lib/selector.js","resolved":"/home/jarri/Desktop/lenovo2020/projects-web/eCommerce/template-store1/node_modules/autoprefixer/lib/prefixer.js"},{"name":"./browsers","loc":{"line":11,"column":23},"parent":"/home/jarri/Desktop/lenovo2020/projects-web/eCommerce/template-store1/node_modules/autoprefixer/lib/selector.js","resolved":"/home/jarri/Desktop/lenovo2020/projects-web/eCommerce/template-store1/node_modules/autoprefixer/lib/browsers.js"},{"name":"./utils","loc":{"line":13,"column":20},"parent":"/home/jarri/Desktop/lenovo2020/projects-web/eCommerce/template-store1/node_modules/autoprefixer/lib/selector.js","resolved":"/home/jarri/Desktop/lenovo2020/projects-web/eCommerce/template-store1/node_modules/autoprefixer/lib/utils.js"}],"generated":{"js":"\"use strict\";\n\nfunction _defaults(obj, defaults) {\n  var keys = Object.getOwnPropertyNames(defaults);\n\n  for (var i = 0; i < keys.length; i++) {\n    var key = keys[i];\n    var value = Object.getOwnPropertyDescriptor(defaults, key);\n\n    if (value && value.configurable && obj[key] === undefined) {\n      Object.defineProperty(obj, key, value);\n    }\n  }\n\n  return obj;\n}\n\nfunction _inheritsLoose(subClass, superClass) {\n  subClass.prototype = Object.create(superClass.prototype);\n  subClass.prototype.constructor = subClass;\n\n  _defaults(subClass, superClass);\n}\n\nvar OldSelector = require('./old-selector');\n\nvar Prefixer = require('./prefixer');\n\nvar Browsers = require('./browsers');\n\nvar utils = require('./utils');\n\nvar Selector = /*#__PURE__*/function (_Prefixer) {\n  _inheritsLoose(Selector, _Prefixer);\n\n  function Selector(name, prefixes, all) {\n    var _this;\n\n    _this = _Prefixer.call(this, name, prefixes, all) || this;\n    _this.regexpCache = {};\n    return _this;\n  }\n  /**\n     * Is rule selectors need to be prefixed\n     */\n\n\n  var _proto = Selector.prototype;\n\n  _proto.check = function check(rule) {\n    if (rule.selector.indexOf(this.name) !== -1) {\n      return !!rule.selector.match(this.regexp());\n    }\n\n    return false;\n  };\n  /**\n     * Return prefixed version of selector\n     */\n\n\n  _proto.prefixed = function prefixed(prefix) {\n    return this.name.replace(/^([^\\w]*)/, \"$1\" + prefix);\n  };\n  /**\n     * Lazy loadRegExp for name\n     */\n\n\n  _proto.regexp = function regexp(prefix) {\n    if (this.regexpCache[prefix]) {\n      return this.regexpCache[prefix];\n    }\n\n    var name = prefix ? this.prefixed(prefix) : this.name;\n    this.regexpCache[prefix] = new RegExp(\"(^|[^:\\\"'=])\" + utils.escapeRegexp(name), 'gi');\n    return this.regexpCache[prefix];\n  };\n  /**\n     * All possible prefixes\n     */\n\n\n  _proto.possible = function possible() {\n    return Browsers.prefixes();\n  };\n  /**\n     * Return all possible selector prefixes\n     */\n\n\n  _proto.prefixeds = function prefixeds(rule) {\n    if (rule._autoprefixerPrefixeds) {\n      return rule._autoprefixerPrefixeds;\n    }\n\n    var prefixeds = {};\n\n    for (var _iterator = this.possible(), _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : _iterator[Symbol.iterator]();;) {\n      var _ref;\n\n      if (_isArray) {\n        if (_i >= _iterator.length) break;\n        _ref = _iterator[_i++];\n      } else {\n        _i = _iterator.next();\n        if (_i.done) break;\n        _ref = _i.value;\n      }\n\n      var prefix = _ref;\n      prefixeds[prefix] = this.replace(rule.selector, prefix);\n    }\n\n    rule._autoprefixerPrefixeds = prefixeds;\n    return rule._autoprefixerPrefixeds;\n  };\n  /**\n     * Is rule already prefixed before\n     */\n\n\n  _proto.already = function already(rule, prefixeds, prefix) {\n    var index = rule.parent.index(rule) - 1;\n\n    while (index >= 0) {\n      var before = rule.parent.nodes[index];\n\n      if (before.type !== 'rule') {\n        return false;\n      }\n\n      var some = false;\n\n      for (var key in prefixeds) {\n        var prefixed = prefixeds[key];\n\n        if (before.selector === prefixed) {\n          if (prefix === key) {\n            return true;\n          } else {\n            some = true;\n            break;\n          }\n        }\n      }\n\n      if (!some) {\n        return false;\n      }\n\n      index -= 1;\n    }\n\n    return false;\n  };\n  /**\n     * Replace selectors by prefixed one\n     */\n\n\n  _proto.replace = function replace(selector, prefix) {\n    return selector.replace(this.regexp(), \"$1\" + this.prefixed(prefix));\n  };\n  /**\n     * Clone and add prefixes for at-rule\n     */\n\n\n  _proto.add = function add(rule, prefix) {\n    var prefixeds = this.prefixeds(rule);\n\n    if (this.already(rule, prefixeds, prefix)) {\n      return;\n    }\n\n    var cloned = this.clone(rule, {\n      selector: prefixeds[prefix]\n    });\n    rule.parent.insertBefore(rule, cloned);\n  };\n  /**\n     * Return function to fast find prefixed selector\n     */\n\n\n  _proto.old = function old(prefix) {\n    return new OldSelector(this, prefix);\n  };\n\n  return Selector;\n}(Prefixer);\n\nmodule.exports = Selector;"},"sourceMaps":null,"error":null,"hash":"92bf54eef5c7347e27a70a66252c72f5","cacheData":{"env":{}}}