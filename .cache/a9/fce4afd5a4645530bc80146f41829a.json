{"id":"../node_modules/websocket-driver/lib/websocket/driver/base.js","dependencies":[{"name":"/home/jarri/Desktop/lenovo2020/projects-web/eCommerce/template-store1/package.json","includedInParent":true,"mtime":1594655165833},{"name":"/home/jarri/Desktop/lenovo2020/projects-web/eCommerce/template-store1/node_modules/websocket-driver/package.json","includedInParent":true,"mtime":1594570878394},{"name":"events","loc":{"line":3,"column":22},"parent":"/home/jarri/Desktop/lenovo2020/projects-web/eCommerce/template-store1/node_modules/websocket-driver/lib/websocket/driver/base.js","resolved":"/home/jarri/Desktop/lenovo2020/projects-web/eCommerce/template-store1/node_modules/events/events.js"},{"name":"util","loc":{"line":4,"column":22},"parent":"/home/jarri/Desktop/lenovo2020/projects-web/eCommerce/template-store1/node_modules/websocket-driver/lib/websocket/driver/base.js","resolved":"/home/jarri/Desktop/lenovo2020/projects-web/eCommerce/template-store1/node_modules/util/util.js"},{"name":"../streams","loc":{"line":5,"column":22},"parent":"/home/jarri/Desktop/lenovo2020/projects-web/eCommerce/template-store1/node_modules/websocket-driver/lib/websocket/driver/base.js","resolved":"/home/jarri/Desktop/lenovo2020/projects-web/eCommerce/template-store1/node_modules/websocket-driver/lib/websocket/streams.js"},{"name":"./headers","loc":{"line":6,"column":22},"parent":"/home/jarri/Desktop/lenovo2020/projects-web/eCommerce/template-store1/node_modules/websocket-driver/lib/websocket/driver/base.js","resolved":"/home/jarri/Desktop/lenovo2020/projects-web/eCommerce/template-store1/node_modules/websocket-driver/lib/websocket/driver/headers.js"},{"name":"./stream_reader","loc":{"line":7,"column":22},"parent":"/home/jarri/Desktop/lenovo2020/projects-web/eCommerce/template-store1/node_modules/websocket-driver/lib/websocket/driver/base.js","resolved":"/home/jarri/Desktop/lenovo2020/projects-web/eCommerce/template-store1/node_modules/websocket-driver/lib/websocket/driver/stream_reader.js"}],"generated":{"js":"'use strict';\n\nvar Emitter = require('events').EventEmitter,\n    util = require('util'),\n    streams = require('../streams'),\n    Headers = require('./headers'),\n    Reader = require('./stream_reader');\n\nvar Base = function (request, url, options) {\n  Emitter.call(this);\n  Base.validateOptions(options || {}, ['maxLength', 'masking', 'requireMasking', 'protocols']);\n  this._request = request;\n  this._reader = new Reader();\n  this._options = options || {};\n  this._maxLength = this._options.maxLength || this.MAX_LENGTH;\n  this._headers = new Headers();\n  this.__queue = [];\n  this.readyState = 0;\n  this.url = url;\n  this.io = new streams.IO(this);\n  this.messages = new streams.Messages(this);\n\n  this._bindEventListeners();\n};\n\nutil.inherits(Base, Emitter);\n\nBase.validateOptions = function (options, validKeys) {\n  for (var key in options) {\n    if (validKeys.indexOf(key) < 0) throw new Error('Unrecognized option: ' + key);\n  }\n};\n\nvar instance = {\n  // This is 64MB, small enough for an average VPS to handle without\n  // crashing from process out of memory\n  MAX_LENGTH: 0x3ffffff,\n  STATES: ['connecting', 'open', 'closing', 'closed'],\n  _bindEventListeners: function () {\n    var self = this; // Protocol errors are informational and do not have to be handled\n\n    this.messages.on('error', function () {});\n    this.on('message', function (event) {\n      var messages = self.messages;\n      if (messages.readable) messages.emit('data', event.data);\n    });\n    this.on('error', function (error) {\n      var messages = self.messages;\n      if (messages.readable) messages.emit('error', error);\n    });\n    this.on('close', function () {\n      var messages = self.messages;\n      if (!messages.readable) return;\n      messages.readable = messages.writable = false;\n      messages.emit('end');\n    });\n  },\n  getState: function () {\n    return this.STATES[this.readyState] || null;\n  },\n  addExtension: function (extension) {\n    return false;\n  },\n  setHeader: function (name, value) {\n    if (this.readyState > 0) return false;\n\n    this._headers.set(name, value);\n\n    return true;\n  },\n  start: function () {\n    if (this.readyState !== 0) return false;\n\n    var response = this._handshakeResponse();\n\n    if (!response) return false;\n\n    this._write(response);\n\n    if (this._stage !== -1) this._open();\n    return true;\n  },\n  text: function (message) {\n    return this.frame(message);\n  },\n  binary: function (message) {\n    return false;\n  },\n  ping: function () {\n    return false;\n  },\n  pong: function () {\n    return false;\n  },\n  close: function (reason, code) {\n    if (this.readyState !== 1) return false;\n    this.readyState = 3;\n    this.emit('close', new Base.CloseEvent(null, null));\n    return true;\n  },\n  _open: function () {\n    this.readyState = 1;\n\n    this.__queue.forEach(function (args) {\n      this.frame.apply(this, args);\n    }, this);\n\n    this.__queue = [];\n    this.emit('open', new Base.OpenEvent());\n  },\n  _queue: function (message) {\n    this.__queue.push(message);\n\n    return true;\n  },\n  _write: function (chunk) {\n    var io = this.io;\n    if (io.readable) io.emit('data', chunk);\n  }\n};\n\nfor (var key in instance) Base.prototype[key] = instance[key];\n\nBase.ConnectEvent = function () {};\n\nBase.OpenEvent = function () {};\n\nBase.CloseEvent = function (code, reason) {\n  this.code = code;\n  this.reason = reason;\n};\n\nBase.MessageEvent = function (data) {\n  this.data = data;\n};\n\nBase.PingEvent = function (data) {\n  this.data = data;\n};\n\nBase.PongEvent = function (data) {\n  this.data = data;\n};\n\nmodule.exports = Base;"},"sourceMaps":null,"error":null,"hash":"77713c3e4e156e9e64711da8e71fdf92","cacheData":{"env":{}}}