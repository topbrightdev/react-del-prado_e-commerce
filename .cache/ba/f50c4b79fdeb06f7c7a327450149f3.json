{"id":"../node_modules/postcss-values-parser/lib/tokenize.js","dependencies":[{"name":"/home/jarri/Desktop/lenovo2020/projects-web/eCommerce/template-store1/package.json","includedInParent":true,"mtime":1594655165833},{"name":"/home/jarri/Desktop/lenovo2020/projects-web/eCommerce/template-store1/node_modules/postcss-values-parser/package.json","includedInParent":true,"mtime":1594570879022},{"name":"util","loc":{"line":36,"column":21},"parent":"/home/jarri/Desktop/lenovo2020/projects-web/eCommerce/template-store1/node_modules/postcss-values-parser/lib/tokenize.js","resolved":"/home/jarri/Desktop/lenovo2020/projects-web/eCommerce/template-store1/node_modules/util/util.js"},{"name":"./errors/TokenizeError","loc":{"line":37,"column":30},"parent":"/home/jarri/Desktop/lenovo2020/projects-web/eCommerce/template-store1/node_modules/postcss-values-parser/lib/tokenize.js","resolved":"/home/jarri/Desktop/lenovo2020/projects-web/eCommerce/template-store1/node_modules/postcss-values-parser/lib/errors/TokenizeError.js"}],"generated":{"js":"'use strict';\n\nvar openBracket = '{'.charCodeAt(0);\nvar closeBracket = '}'.charCodeAt(0);\nvar openParen = '('.charCodeAt(0);\nvar closeParen = ')'.charCodeAt(0);\nvar singleQuote = '\\''.charCodeAt(0);\nvar doubleQuote = '\"'.charCodeAt(0);\nvar backslash = '\\\\'.charCodeAt(0);\nvar slash = '/'.charCodeAt(0);\nvar period = '.'.charCodeAt(0);\nvar comma = ','.charCodeAt(0);\nvar colon = ':'.charCodeAt(0);\nvar asterisk = '*'.charCodeAt(0);\nvar minus = '-'.charCodeAt(0);\nvar plus = '+'.charCodeAt(0);\nvar pound = '#'.charCodeAt(0);\nvar newline = '\\n'.charCodeAt(0);\nvar space = ' '.charCodeAt(0);\nvar feed = '\\f'.charCodeAt(0);\nvar tab = '\\t'.charCodeAt(0);\nvar cr = '\\r'.charCodeAt(0);\nvar at = '@'.charCodeAt(0);\nvar lowerE = 'e'.charCodeAt(0);\nvar upperE = 'E'.charCodeAt(0);\nvar digit0 = '0'.charCodeAt(0);\nvar digit9 = '9'.charCodeAt(0);\nvar lowerU = 'u'.charCodeAt(0);\nvar upperU = 'U'.charCodeAt(0);\nvar atEnd = /[ \\n\\t\\r\\{\\(\\)'\"\\\\;,/]/g;\nvar wordEnd = /[ \\n\\t\\r\\(\\)\\{\\}\\*:;@!&'\"\\+\\|~>,\\[\\]\\\\]|\\/(?=\\*)/g;\nvar wordEndNum = /[ \\n\\t\\r\\(\\)\\{\\}\\*:;@!&'\"\\-\\+\\|~>,\\[\\]\\\\]|\\//g;\nvar alphaNum = /^[a-z0-9]/i;\nvar unicodeRange = /^[a-f0-9?\\-]/i;\n\nvar util = require('util');\n\nvar TokenizeError = require('./errors/TokenizeError');\n\nmodule.exports = function tokenize(input, options) {\n  options = options || {};\n  var tokens = [],\n      css = input.valueOf(),\n      length = css.length,\n      offset = -1,\n      line = 1,\n      pos = 0,\n      parentCount = 0,\n      isURLArg = null,\n      code,\n      next,\n      quote,\n      lines,\n      last,\n      content,\n      escape,\n      nextLine,\n      nextOffset,\n      escaped,\n      escapePos,\n      nextChar;\n\n  function unclosed(what) {\n    var message = util.format('Unclosed %s at line: %d, column: %d, token: %d', what, line, pos - offset, pos);\n    throw new TokenizeError(message);\n  }\n\n  function tokenizeError() {\n    var message = util.format('Syntax error at line: %d, column: %d, token: %d', line, pos - offset, pos);\n    throw new TokenizeError(message);\n  }\n\n  while (pos < length) {\n    code = css.charCodeAt(pos);\n\n    if (code === newline) {\n      offset = pos;\n      line += 1;\n    }\n\n    switch (code) {\n      case newline:\n      case space:\n      case tab:\n      case cr:\n      case feed:\n        next = pos;\n\n        do {\n          next += 1;\n          code = css.charCodeAt(next);\n\n          if (code === newline) {\n            offset = next;\n            line += 1;\n          }\n        } while (code === space || code === newline || code === tab || code === cr || code === feed);\n\n        tokens.push(['space', css.slice(pos, next), line, pos - offset, line, next - offset, pos]);\n        pos = next - 1;\n        break;\n\n      case colon:\n        next = pos + 1;\n        tokens.push(['colon', css.slice(pos, next), line, pos - offset, line, next - offset, pos]);\n        pos = next - 1;\n        break;\n\n      case comma:\n        next = pos + 1;\n        tokens.push(['comma', css.slice(pos, next), line, pos - offset, line, next - offset, pos]);\n        pos = next - 1;\n        break;\n\n      case openBracket:\n        tokens.push(['{', '{', line, pos - offset, line, next - offset, pos]);\n        break;\n\n      case closeBracket:\n        tokens.push(['}', '}', line, pos - offset, line, next - offset, pos]);\n        break;\n\n      case openParen:\n        parentCount++;\n        isURLArg = !isURLArg && parentCount === 1 && tokens.length > 0 && tokens[tokens.length - 1][0] === \"word\" && tokens[tokens.length - 1][1] === \"url\";\n        tokens.push(['(', '(', line, pos - offset, line, next - offset, pos]);\n        break;\n\n      case closeParen:\n        parentCount--;\n        isURLArg = !isURLArg && parentCount === 1;\n        tokens.push([')', ')', line, pos - offset, line, next - offset, pos]);\n        break;\n\n      case singleQuote:\n      case doubleQuote:\n        quote = code === singleQuote ? '\\'' : '\"';\n        next = pos;\n\n        do {\n          escaped = false;\n          next = css.indexOf(quote, next + 1);\n\n          if (next === -1) {\n            unclosed('quote', quote);\n          }\n\n          escapePos = next;\n\n          while (css.charCodeAt(escapePos - 1) === backslash) {\n            escapePos -= 1;\n            escaped = !escaped;\n          }\n        } while (escaped);\n\n        tokens.push(['string', css.slice(pos, next + 1), line, pos - offset, line, next - offset, pos]);\n        pos = next;\n        break;\n\n      case at:\n        atEnd.lastIndex = pos + 1;\n        atEnd.test(css);\n\n        if (atEnd.lastIndex === 0) {\n          next = css.length - 1;\n        } else {\n          next = atEnd.lastIndex - 2;\n        }\n\n        tokens.push(['atword', css.slice(pos, next + 1), line, pos - offset, line, next - offset, pos]);\n        pos = next;\n        break;\n\n      case backslash:\n        next = pos;\n        code = css.charCodeAt(next + 1);\n\n        if (escape && code !== slash && code !== space && code !== newline && code !== tab && code !== cr && code !== feed) {\n          next += 1;\n        }\n\n        tokens.push(['word', css.slice(pos, next + 1), line, pos - offset, line, next - offset, pos]);\n        pos = next;\n        break;\n\n      case plus:\n      case minus:\n      case asterisk:\n        next = pos + 1;\n        nextChar = css.slice(pos + 1, next + 1);\n        var prevChar = css.slice(pos - 1, pos); // if the operator is immediately followed by a word character, then we\n        // have a prefix of some kind, and should fall-through. eg. -webkit\n        // look for --* for custom variables\n\n        if (code === minus && nextChar.charCodeAt(0) === minus) {\n          next++;\n          tokens.push(['word', css.slice(pos, next), line, pos - offset, line, next - offset, pos]);\n          pos = next - 1;\n          break;\n        }\n\n        tokens.push(['operator', css.slice(pos, next), line, pos - offset, line, next - offset, pos]);\n        pos = next - 1;\n        break;\n\n      default:\n        if (code === slash && (css.charCodeAt(pos + 1) === asterisk || options.loose && !isURLArg && css.charCodeAt(pos + 1) === slash)) {\n          var isStandardComment = css.charCodeAt(pos + 1) === asterisk;\n\n          if (isStandardComment) {\n            next = css.indexOf('*/', pos + 2) + 1;\n\n            if (next === 0) {\n              unclosed('comment', '*/');\n            }\n          } else {\n            var newlinePos = css.indexOf('\\n', pos + 2);\n            next = newlinePos !== -1 ? newlinePos - 1 : length;\n          }\n\n          content = css.slice(pos, next + 1);\n          lines = content.split('\\n');\n          last = lines.length - 1;\n\n          if (last > 0) {\n            nextLine = line + last;\n            nextOffset = next - lines[last].length;\n          } else {\n            nextLine = line;\n            nextOffset = offset;\n          }\n\n          tokens.push(['comment', content, line, pos - offset, nextLine, next - nextOffset, pos]);\n          offset = nextOffset;\n          line = nextLine;\n          pos = next;\n        } else if (code === pound && !alphaNum.test(css.slice(pos + 1, pos + 2))) {\n          next = pos + 1;\n          tokens.push(['#', css.slice(pos, next), line, pos - offset, line, next - offset, pos]);\n          pos = next - 1;\n        } else if ((code === lowerU || code === upperU) && css.charCodeAt(pos + 1) === plus) {\n          next = pos + 2;\n\n          do {\n            next += 1;\n            code = css.charCodeAt(next);\n          } while (next < length && unicodeRange.test(css.slice(next, next + 1)));\n\n          tokens.push(['unicoderange', css.slice(pos, next), line, pos - offset, line, next - offset, pos]);\n          pos = next - 1;\n        } // catch a regular slash, that isn't a comment\n        else if (code === slash) {\n            next = pos + 1;\n            tokens.push(['operator', css.slice(pos, next), line, pos - offset, line, next - offset, pos]);\n            pos = next - 1;\n          } else {\n            var regex = wordEnd; // we're dealing with a word that starts with a number\n            // those get treated differently\n\n            if (code >= digit0 && code <= digit9) {\n              regex = wordEndNum;\n            }\n\n            regex.lastIndex = pos + 1;\n            regex.test(css);\n\n            if (regex.lastIndex === 0) {\n              next = css.length - 1;\n            } else {\n              next = regex.lastIndex - 2;\n            } // Exponential number notation with minus or plus: 1e-10, 1e+10\n\n\n            if (regex === wordEndNum || code === period) {\n              var ncode = css.charCodeAt(next),\n                  ncode1 = css.charCodeAt(next + 1),\n                  ncode2 = css.charCodeAt(next + 2);\n\n              if ((ncode === lowerE || ncode === upperE) && (ncode1 === minus || ncode1 === plus) && ncode2 >= digit0 && ncode2 <= digit9) {\n                wordEndNum.lastIndex = next + 2;\n                wordEndNum.test(css);\n\n                if (wordEndNum.lastIndex === 0) {\n                  next = css.length - 1;\n                } else {\n                  next = wordEndNum.lastIndex - 2;\n                }\n              }\n            }\n\n            tokens.push(['word', css.slice(pos, next + 1), line, pos - offset, line, next - offset, pos]);\n            pos = next;\n          }\n\n        break;\n    }\n\n    pos++;\n  }\n\n  return tokens;\n};"},"sourceMaps":null,"error":null,"hash":"8702d838657c3396e8ceac46f833b6c6","cacheData":{"env":{}}}