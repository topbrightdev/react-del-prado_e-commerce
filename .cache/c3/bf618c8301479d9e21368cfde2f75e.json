{"id":"../node_modules/source-list-map/lib/SingleLineNode.js","dependencies":[{"name":"/home/jarri/Desktop/lenovo2020/projects-web/eCommerce/template-store1/package.json","includedInParent":true,"mtime":1594655165833},{"name":"/home/jarri/Desktop/lenovo2020/projects-web/eCommerce/template-store1/node_modules/source-list-map/package.json","includedInParent":true,"mtime":1594306881450},{"name":"./base64-vlq","loc":{"line":7,"column":26},"parent":"/home/jarri/Desktop/lenovo2020/projects-web/eCommerce/template-store1/node_modules/source-list-map/lib/SingleLineNode.js","resolved":"/home/jarri/Desktop/lenovo2020/projects-web/eCommerce/template-store1/node_modules/source-list-map/lib/base64-vlq.js"},{"name":"./helpers","loc":{"line":9,"column":34},"parent":"/home/jarri/Desktop/lenovo2020/projects-web/eCommerce/template-store1/node_modules/source-list-map/lib/SingleLineNode.js","resolved":"/home/jarri/Desktop/lenovo2020/projects-web/eCommerce/template-store1/node_modules/source-list-map/lib/helpers.js"},{"name":"./SourceNode","loc":{"line":93,"column":27},"parent":"/home/jarri/Desktop/lenovo2020/projects-web/eCommerce/template-store1/node_modules/source-list-map/lib/SingleLineNode.js","resolved":"/home/jarri/Desktop/lenovo2020/projects-web/eCommerce/template-store1/node_modules/source-list-map/lib/SourceNode.js"}],"generated":{"js":"/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\"use strict\";\n\nconst base64VLQ = require(\"./base64-vlq\");\nconst getNumberOfLines = require(\"./helpers\").getNumberOfLines;\nconst getUnfinishedLine = require(\"./helpers\").getUnfinishedLine;\n\nconst LINE_MAPPING = \";AAAA\";\n\nclass SingleLineNode {\n\n\tconstructor(generatedCode, source, originalSource, line) {\n\t\tthis.generatedCode = generatedCode;\n\t\tthis.originalSource = originalSource;\n\t\tthis.source = source;\n\t\tthis.line = line || 1;\n\t\tthis._numberOfLines = getNumberOfLines(this.generatedCode);\n\t\tthis._endsWithNewLine = generatedCode[generatedCode.length - 1] === \"\\n\";\n\t}\n\n\tclone() {\n\t\treturn new SingleLineNode(this.generatedCode, this.source, this.originalSource, this.line);\n\t}\n\n\tgetGeneratedCode() {\n\t\treturn this.generatedCode;\n\t}\n\n\tgetMappings(mappingsContext) {\n\t\tif(!this.generatedCode)\n\t\t\treturn \"\";\n\t\tconst lines = this._numberOfLines;\n\t\tconst sourceIdx = mappingsContext.ensureSource(this.source, this.originalSource);\n\t\tlet mappings = \"A\"; // generated column 0\n\t\tif(mappingsContext.unfinishedGeneratedLine)\n\t\t\tmappings = \",\" + base64VLQ.encode(mappingsContext.unfinishedGeneratedLine);\n\t\tmappings += base64VLQ.encode(sourceIdx - mappingsContext.currentSource); // source index\n\t\tmappings += base64VLQ.encode(this.line - mappingsContext.currentOriginalLine); // original line index\n\t\tmappings += \"A\"; // original column 0\n\t\tmappingsContext.currentSource = sourceIdx;\n\t\tmappingsContext.currentOriginalLine = this.line;\n\t\tconst unfinishedGeneratedLine = mappingsContext.unfinishedGeneratedLine = getUnfinishedLine(this.generatedCode)\n\t\tmappings += Array(lines).join(LINE_MAPPING);\n\t\tif(unfinishedGeneratedLine === 0) {\n\t\t\tmappings += \";\";\n\t\t} else {\n\t\t\tif(lines !== 0)\n\t\t\t\tmappings += LINE_MAPPING;\n\t\t}\n\t\treturn mappings;\n\t}\n\n\tgetNormalizedNodes() {\n\t\treturn [this];\n\t}\n\n\tmapGeneratedCode(fn) {\n\t\tconst generatedCode = fn(this.generatedCode);\n\t\treturn new SingleLineNode(generatedCode, this.source, this.originalSource, this.line);\n\t}\n\n\tmerge(otherNode) {\n\t\tif(otherNode instanceof SingleLineNode) {\n\t\t\treturn this.mergeSingleLineNode(otherNode);\n\t\t}\n\t\treturn false;\n\t}\n\n\tmergeSingleLineNode(otherNode) {\n\t\tif(this.source === otherNode.source &&\n\t\t\tthis.originalSource === otherNode.originalSource) {\n\t\t\tif(this.line === otherNode.line) {\n\t\t\t\tthis.generatedCode += otherNode.generatedCode;\n\t\t\t\tthis._numberOfLines += otherNode._numberOfLines;\n\t\t\t\tthis._endsWithNewLine = otherNode._endsWithNewLine;\n\t\t\t\treturn this;\n\t\t\t} else if(this.line + 1 === otherNode.line && \n\t\t\t\tthis._endsWithNewLine &&\n\t\t\t\tthis._numberOfLines === 1 && \n\t\t\t\totherNode._numberOfLines <= 1) {\n\t\t\t\treturn new SourceNode(this.generatedCode + otherNode.generatedCode, this.source, this.originalSource, this.line);\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n}\n\nmodule.exports = SingleLineNode;\n\nconst SourceNode = require(\"./SourceNode\"); // circular dependency\n"},"sourceMaps":null,"error":null,"hash":"20436815a7d260a9d9505e8a7e50f8e1","cacheData":{"env":{}}}