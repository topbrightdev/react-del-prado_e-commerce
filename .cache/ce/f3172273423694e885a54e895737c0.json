{"id":"../node_modules/fork-ts-checker-webpack-plugin-alt/lib/index.js","dependencies":[{"name":"/home/jarri/Desktop/lenovo2020/projects-web/eCommerce/template-store1/package.json","includedInParent":true,"mtime":1594655291184},{"name":"/home/jarri/Desktop/lenovo2020/projects-web/eCommerce/template-store1/node_modules/fork-ts-checker-webpack-plugin-alt/package.json","includedInParent":true,"mtime":1594306880006},{"name":"path","loc":{"line":2,"column":19},"parent":"/home/jarri/Desktop/lenovo2020/projects-web/eCommerce/template-store1/node_modules/fork-ts-checker-webpack-plugin-alt/lib/index.js","resolved":"/home/jarri/Desktop/lenovo2020/projects-web/eCommerce/template-store1/node_modules/path-browserify/index.js"},{"name":"process","loc":{"line":3,"column":22},"parent":"/home/jarri/Desktop/lenovo2020/projects-web/eCommerce/template-store1/node_modules/fork-ts-checker-webpack-plugin-alt/lib/index.js","resolved":"/home/jarri/Desktop/lenovo2020/projects-web/eCommerce/template-store1/node_modules/process/browser.js"},{"name":"child_process","loc":{"line":4,"column":27},"parent":"/home/jarri/Desktop/lenovo2020/projects-web/eCommerce/template-store1/node_modules/fork-ts-checker-webpack-plugin-alt/lib/index.js","resolved":"/home/jarri/Desktop/lenovo2020/projects-web/eCommerce/template-store1/node_modules/parcel-bundler/src/builtins/_empty.js"},{"name":"chalk","loc":{"line":5,"column":22},"parent":"/home/jarri/Desktop/lenovo2020/projects-web/eCommerce/template-store1/node_modules/fork-ts-checker-webpack-plugin-alt/lib/index.js","resolved":"/home/jarri/Desktop/lenovo2020/projects-web/eCommerce/template-store1/node_modules/chalk/index.js"},{"name":"fs","loc":{"line":6,"column":17},"parent":"/home/jarri/Desktop/lenovo2020/projects-web/eCommerce/template-store1/node_modules/fork-ts-checker-webpack-plugin-alt/lib/index.js","resolved":"/home/jarri/Desktop/lenovo2020/projects-web/eCommerce/template-store1/node_modules/parcel-bundler/src/builtins/_empty.js"},{"name":"micromatch","loc":{"line":7,"column":25},"parent":"/home/jarri/Desktop/lenovo2020/projects-web/eCommerce/template-store1/node_modules/fork-ts-checker-webpack-plugin-alt/lib/index.js","resolved":"/home/jarri/Desktop/lenovo2020/projects-web/eCommerce/template-store1/node_modules/fork-ts-checker-webpack-plugin-alt/node_modules/micromatch/index.js"},{"name":"os","loc":{"line":8,"column":17},"parent":"/home/jarri/Desktop/lenovo2020/projects-web/eCommerce/template-store1/node_modules/fork-ts-checker-webpack-plugin-alt/lib/index.js","resolved":"/home/jarri/Desktop/lenovo2020/projects-web/eCommerce/template-store1/node_modules/os-browserify/browser.js"},{"name":"lodash/isString","loc":{"line":9,"column":23},"parent":"/home/jarri/Desktop/lenovo2020/projects-web/eCommerce/template-store1/node_modules/fork-ts-checker-webpack-plugin-alt/lib/index.js","resolved":"/home/jarri/Desktop/lenovo2020/projects-web/eCommerce/template-store1/node_modules/lodash/isString.js"},{"name":"lodash/isFunction","loc":{"line":10,"column":25},"parent":"/home/jarri/Desktop/lenovo2020/projects-web/eCommerce/template-store1/node_modules/fork-ts-checker-webpack-plugin-alt/lib/index.js","resolved":"/home/jarri/Desktop/lenovo2020/projects-web/eCommerce/template-store1/node_modules/lodash/isFunction.js"},{"name":"./CancellationToken","loc":{"line":11,"column":34},"parent":"/home/jarri/Desktop/lenovo2020/projects-web/eCommerce/template-store1/node_modules/fork-ts-checker-webpack-plugin-alt/lib/index.js","resolved":"/home/jarri/Desktop/lenovo2020/projects-web/eCommerce/template-store1/node_modules/fork-ts-checker-webpack-plugin-alt/lib/CancellationToken.js"},{"name":"./NormalizedMessage","loc":{"line":12,"column":34},"parent":"/home/jarri/Desktop/lenovo2020/projects-web/eCommerce/template-store1/node_modules/fork-ts-checker-webpack-plugin-alt/lib/index.js","resolved":"/home/jarri/Desktop/lenovo2020/projects-web/eCommerce/template-store1/node_modules/fork-ts-checker-webpack-plugin-alt/lib/NormalizedMessage.js"},{"name":"./formatter/defaultFormatter","loc":{"line":13,"column":33},"parent":"/home/jarri/Desktop/lenovo2020/projects-web/eCommerce/template-store1/node_modules/fork-ts-checker-webpack-plugin-alt/lib/index.js","resolved":"/home/jarri/Desktop/lenovo2020/projects-web/eCommerce/template-store1/node_modules/fork-ts-checker-webpack-plugin-alt/lib/formatter/defaultFormatter.js"},{"name":"./formatter/codeframeFormatter","loc":{"line":14,"column":35},"parent":"/home/jarri/Desktop/lenovo2020/projects-web/eCommerce/template-store1/node_modules/fork-ts-checker-webpack-plugin-alt/lib/index.js","resolved":"/home/jarri/Desktop/lenovo2020/projects-web/eCommerce/template-store1/node_modules/fork-ts-checker-webpack-plugin-alt/lib/formatter/codeframeFormatter.js"},{"name":"tapable","loc":{"line":15,"column":24},"parent":"/home/jarri/Desktop/lenovo2020/projects-web/eCommerce/template-store1/node_modules/fork-ts-checker-webpack-plugin-alt/lib/index.js","resolved":"/home/jarri/Desktop/lenovo2020/projects-web/eCommerce/template-store1/node_modules/tapable/lib/index.js"},{"name":"tslint","optional":true,"loc":{"line":93,"column":28},"parent":"/home/jarri/Desktop/lenovo2020/projects-web/eCommerce/template-store1/node_modules/fork-ts-checker-webpack-plugin-alt/lib/index.js"}],"generated":{"js":"\nvar __dirname = \"/home/jarri/Desktop/lenovo2020/projects-web/eCommerce/template-store1/node_modules/fork-ts-checker-webpack-plugin-alt/lib\";\n\"use strict\";\n\nvar path = require(\"path\");\n\nvar process = require(\"process\");\n\nvar childProcess = require(\"child_process\");\n\nvar chalk_1 = require(\"chalk\");\n\nvar fs = require(\"fs\");\n\nvar micromatch = require(\"micromatch\");\n\nvar os = require(\"os\");\n\nvar isString = require(\"lodash/isString\");\n\nvar isFunction = require(\"lodash/isFunction\");\n\nvar CancellationToken_1 = require(\"./CancellationToken\");\n\nvar NormalizedMessage_1 = require(\"./NormalizedMessage\");\n\nvar defaultFormatter_1 = require(\"./formatter/defaultFormatter\");\n\nvar codeframeFormatter_1 = require(\"./formatter/codeframeFormatter\");\n\nvar tapable_1 = require(\"tapable\");\n\nvar checkerPluginName = 'fork-ts-checker-webpack-plugin';\nvar customHooks = {\n  forkTsCheckerServiceBeforeStart: 'fork-ts-checker-service-before-start',\n  forkTsCheckerCancel: 'fork-ts-checker-cancel',\n  forkTsCheckerServiceStartError: 'fork-ts-checker-service-start-error',\n  forkTsCheckerWaiting: 'fork-ts-checker-waiting',\n  forkTsCheckerServiceStart: 'fork-ts-checker-service-start',\n  forkTsCheckerReceive: 'fork-ts-checker-receive',\n  forkTsCheckerServiceOutOfMemory: 'fork-ts-checker-service-out-of-memory',\n  forkTsCheckerEmit: 'fork-ts-checker-emit',\n  forkTsCheckerDone: 'fork-ts-checker-done'\n};\n/**\n * ForkTsCheckerWebpackPlugin\n * Runs typescript type checker and linter (tslint) on separate process.\n * This speed-ups build a lot.\n *\n * Options description in README.md\n */\n\nvar ForkTsCheckerWebpackPlugin =\n/** @class */\nfunction () {\n  function ForkTsCheckerWebpackPlugin(options) {\n    options = options || {};\n    this.options = Object.assign({}, options);\n    this.tsconfig = options.tsconfig || './tsconfig.json';\n    this.compilerOptions = typeof options.compilerOptions === 'object' ? options.compilerOptions : {};\n    this.tslint = options.tslint ? options.tslint === true ? './tslint.json' : options.tslint : undefined;\n    this.watch = isString(options.watch) ? [options.watch] : options.watch || [];\n    this.ignoreDiagnostics = options.ignoreDiagnostics || [];\n    this.ignoreLints = options.ignoreLints || [];\n    this.reportFiles = options.reportFiles || [];\n    this.logger = options.logger || console;\n    this.silent = options.silent === true; // default false\n\n    this.async = options.async !== false; // default true\n\n    this.checkSyntacticErrors = options.checkSyntacticErrors === true; // default false\n\n    this.workersNumber = options.workers || ForkTsCheckerWebpackPlugin.ONE_CPU;\n    this.memoryLimit = options.memoryLimit || ForkTsCheckerWebpackPlugin.DEFAULT_MEMORY_LIMIT;\n    this.useColors = options.colors !== false; // default true\n\n    this.colors = new chalk_1.default.constructor({\n      enabled: this.useColors\n    });\n    this.formatter = options.formatter && isFunction(options.formatter) ? options.formatter : ForkTsCheckerWebpackPlugin.createFormatter(options.formatter || 'default', options.formatterOptions || {});\n    this.tsconfigPath = undefined;\n    this.tslintPath = undefined;\n    this.watchPaths = [];\n    this.compiler = undefined;\n    this.started = undefined;\n    this.elapsed = undefined;\n    this.cancellationToken = undefined;\n    this.isWatching = false;\n    this.checkDone = false;\n    this.compilationDone = false;\n    this.diagnostics = [];\n    this.lints = [];\n    this.emitCallback = this.createNoopEmitCallback();\n    this.doneCallback = this.createDoneCallback(); // tslint:disable-next-line:no-implicit-dependencies\n\n    this.typescriptPath = options.typescript || require.resolve('typescript');\n\n    try {\n      this.typescriptVersion = require(this.typescriptPath).version;\n    } catch (_ignored) {\n      throw new Error('When you use this plugin you must install `typescript`.');\n    }\n\n    try {\n      this.tslintVersion = this.tslint ? // tslint:disable-next-line:no-implicit-dependencies\n      require('tslint').Linter.VERSION : undefined;\n    } catch (_ignored) {\n      throw new Error('When you use `tslint` option, make sure to install `tslint`.');\n    }\n\n    this.vue = options.vue === true; // default false\n  }\n\n  ForkTsCheckerWebpackPlugin.createFormatter = function (type, options) {\n    switch (type) {\n      case 'default':\n        return defaultFormatter_1.createDefaultFormatter();\n\n      case 'codeframe':\n        return codeframeFormatter_1.createCodeframeFormatter(options);\n\n      default:\n        throw new Error('Unknown \"' + type + '\" formatter. Available are: default, codeframe.');\n    }\n  };\n\n  ForkTsCheckerWebpackPlugin.prototype.apply = function (compiler) {\n    this.compiler = compiler;\n    this.tsconfigPath = this.computeContextPath(this.tsconfig);\n    this.tslintPath = this.tslint ? this.computeContextPath(this.tslint) : null;\n    this.watchPaths = this.watch.map(this.computeContextPath.bind(this)); // validate config\n\n    var tsconfigOk = fs.existsSync(this.tsconfigPath);\n    var tslintOk = !this.tslintPath || fs.existsSync(this.tslintPath); // validate logger\n\n    if (this.logger) {\n      if (!this.logger.error || !this.logger.warn || !this.logger.info) {\n        throw new Error(\"Invalid logger object - doesn't provide `error`, `warn` or `info` method.\");\n      }\n    }\n\n    if (tsconfigOk && tslintOk) {\n      if ('hooks' in compiler) {\n        this.registerCustomHooks();\n      }\n\n      this.pluginStart();\n      this.pluginStop();\n      this.pluginCompile();\n      this.pluginEmit();\n      this.pluginDone();\n    } else {\n      if (!tsconfigOk) {\n        throw new Error('Cannot find \"' + this.tsconfigPath + '\" file. Please check webpack and ForkTsCheckerWebpackPlugin configuration. \\n' + 'Possible errors: \\n' + '  - wrong `context` directory in webpack configuration' + ' (if `tsconfig` is not set or is a relative path in fork plugin configuration)\\n' + '  - wrong `tsconfig` path in fork plugin configuration' + ' (should be a relative or absolute path)');\n      }\n\n      if (!tslintOk) {\n        throw new Error('Cannot find \"' + this.tslintPath + '\" file. Please check webpack and ForkTsCheckerWebpackPlugin configuration. \\n' + 'Possible errors: \\n' + '  - wrong `context` directory in webpack configuration' + ' (if `tslint` is not set or is a relative path in fork plugin configuration)\\n' + '  - wrong `tslint` path in fork plugin configuration' + ' (should be a relative or absolute path)\\n' + '  - `tslint` path is not set to false in fork plugin configuration' + ' (if you want to disable tslint support)');\n      }\n    }\n  };\n\n  ForkTsCheckerWebpackPlugin.prototype.computeContextPath = function (filePath) {\n    return path.isAbsolute(filePath) ? filePath : path.resolve(this.compiler.options.context, filePath);\n  };\n\n  ForkTsCheckerWebpackPlugin.prototype.pluginStart = function () {\n    var _this = this;\n\n    var run = function run(_compiler, callback) {\n      _this.isWatching = false;\n      callback();\n    };\n\n    var watchRun = function watchRun(_compiler, callback) {\n      _this.isWatching = true;\n      callback();\n    };\n\n    if ('hooks' in this.compiler) {\n      // webpack 4\n      this.compiler.hooks.run.tapAsync(checkerPluginName, run);\n      this.compiler.hooks.watchRun.tapAsync(checkerPluginName, watchRun);\n    } else {\n      // webpack 2 / 3\n      this.compiler.plugin('run', run);\n      this.compiler.plugin('watch-run', watchRun);\n    }\n  };\n\n  ForkTsCheckerWebpackPlugin.prototype.pluginStop = function () {\n    var _this = this;\n\n    var watchClose = function watchClose() {\n      _this.killService();\n    };\n\n    var done = function done(_stats) {\n      if (!_this.isWatching) {\n        _this.killService();\n      }\n    };\n\n    if ('hooks' in this.compiler) {\n      // webpack 4\n      this.compiler.hooks.watchClose.tap(checkerPluginName, watchClose);\n      this.compiler.hooks.done.tap(checkerPluginName, done);\n    } else {\n      // webpack 2 / 3\n      this.compiler.plugin('watch-close', watchClose);\n      this.compiler.plugin('done', done);\n    }\n\n    process.on('exit', function () {\n      _this.killService();\n    });\n  };\n\n  ForkTsCheckerWebpackPlugin.prototype.registerCustomHooks = function () {\n    if (this.compiler.hooks.forkTsCheckerServiceBeforeStart || this.compiler.hooks.forkTsCheckerCancel || this.compiler.hooks.forkTsCheckerServiceStartError || this.compiler.hooks.forkTsCheckerWaiting || this.compiler.hooks.forkTsCheckerServiceStart || this.compiler.hooks.forkTsCheckerReceive || this.compiler.hooks.forkTsCheckerServiceOutOfMemory || this.compiler.hooks.forkTsCheckerDone || this.compiler.hooks.forkTsCheckerEmit) {\n      throw new Error('fork-ts-checker-webpack-plugin hooks are already in use');\n    }\n\n    this.compiler.hooks.forkTsCheckerServiceBeforeStart = new tapable_1.AsyncSeriesHook([]);\n    this.compiler.hooks.forkTsCheckerCancel = new tapable_1.SyncHook(['cancellationToken']);\n    this.compiler.hooks.forkTsCheckerServiceStartError = new tapable_1.SyncHook(['error']);\n    this.compiler.hooks.forkTsCheckerWaiting = new tapable_1.SyncHook(['hasTsLint']);\n    this.compiler.hooks.forkTsCheckerServiceStart = new tapable_1.SyncHook(['tsconfigPath', 'tslintPath', 'watchPaths', 'workersNumber', 'memoryLimit']);\n    this.compiler.hooks.forkTsCheckerReceive = new tapable_1.SyncHook(['diagnostics', 'lints']);\n    this.compiler.hooks.forkTsCheckerServiceOutOfMemory = new tapable_1.SyncHook([]);\n    this.compiler.hooks.forkTsCheckerEmit = new tapable_1.SyncHook(['diagnostics', 'lints', 'elapsed']);\n    this.compiler.hooks.forkTsCheckerDone = new tapable_1.SyncHook(['diagnostics', 'lints', 'elapsed']); // for backwards compatibility\n\n    this.compiler._pluginCompat.tap(checkerPluginName, function (options) {\n      switch (options.name) {\n        case customHooks.forkTsCheckerServiceBeforeStart:\n          options.async = true;\n          break;\n\n        case customHooks.forkTsCheckerCancel:\n        case customHooks.forkTsCheckerServiceStartError:\n        case customHooks.forkTsCheckerWaiting:\n        case customHooks.forkTsCheckerServiceStart:\n        case customHooks.forkTsCheckerReceive:\n        case customHooks.forkTsCheckerServiceOutOfMemory:\n        case customHooks.forkTsCheckerEmit:\n        case customHooks.forkTsCheckerDone:\n          return true;\n      }\n\n      return undefined;\n    });\n  };\n\n  ForkTsCheckerWebpackPlugin.prototype.pluginCompile = function () {\n    var _this = this;\n\n    if ('hooks' in this.compiler) {\n      // webpack 4\n      this.compiler.hooks.compile.tap(checkerPluginName, function () {\n        _this.compilationDone = false;\n\n        _this.compiler.hooks.forkTsCheckerServiceBeforeStart.callAsync(function () {\n          if (_this.cancellationToken) {\n            // request cancellation if there is not finished job\n            _this.cancellationToken.requestCancellation();\n\n            _this.compiler.hooks.forkTsCheckerCancel.call(_this.cancellationToken);\n          }\n\n          _this.checkDone = false;\n          _this.started = process.hrtime(); // create new token for current job\n\n          _this.cancellationToken = new CancellationToken_1.CancellationToken(undefined, undefined);\n\n          if (!_this.service || !_this.service.connected) {\n            _this.spawnService();\n          }\n\n          try {\n            _this.service.send(_this.cancellationToken);\n          } catch (error) {\n            if (!_this.silent && _this.logger) {\n              _this.logger.error(_this.colors.red('Cannot start checker service: ' + (error ? error.toString() : 'Unknown error')));\n            }\n\n            _this.compiler.hooks.forkTsCheckerServiceStartError.call(error);\n          }\n        });\n      });\n    } else {\n      // webpack 2 / 3\n      this.compiler.plugin('compile', function () {\n        _this.compilationDone = false;\n\n        _this.compiler.applyPluginsAsync('fork-ts-checker-service-before-start', function () {\n          if (_this.cancellationToken) {\n            // request cancellation if there is not finished job\n            _this.cancellationToken.requestCancellation();\n\n            _this.compiler.applyPlugins('fork-ts-checker-cancel', _this.cancellationToken);\n          }\n\n          _this.checkDone = false;\n          _this.started = process.hrtime(); // create new token for current job\n\n          _this.cancellationToken = new CancellationToken_1.CancellationToken(undefined, undefined);\n\n          if (!_this.service || !_this.service.connected) {\n            _this.spawnService();\n          }\n\n          try {\n            _this.service.send(_this.cancellationToken);\n          } catch (error) {\n            if (!_this.silent && _this.logger) {\n              _this.logger.error(_this.colors.red('Cannot start checker service: ' + (error ? error.toString() : 'Unknown error')));\n            }\n\n            _this.compiler.applyPlugins('fork-ts-checker-service-start-error', error);\n          }\n        });\n      });\n    }\n  };\n\n  ForkTsCheckerWebpackPlugin.prototype.pluginEmit = function () {\n    var _this = this;\n\n    var emit = function emit(compilation, callback) {\n      if (_this.isWatching && _this.async) {\n        callback();\n        return;\n      }\n\n      _this.emitCallback = _this.createEmitCallback(compilation, callback);\n\n      if (_this.checkDone) {\n        _this.emitCallback();\n      }\n\n      _this.compilationDone = true;\n    };\n\n    if ('hooks' in this.compiler) {\n      // webpack 4\n      this.compiler.hooks.emit.tapAsync(checkerPluginName, emit);\n    } else {\n      // webpack 2 / 3\n      this.compiler.plugin('emit', emit);\n    }\n  };\n\n  ForkTsCheckerWebpackPlugin.prototype.pluginDone = function () {\n    var _this = this;\n\n    if ('hooks' in this.compiler) {\n      // webpack 4\n      this.compiler.hooks.done.tap(checkerPluginName, function (_stats) {\n        if (!_this.isWatching || !_this.async) {\n          return;\n        }\n\n        if (_this.checkDone) {\n          _this.doneCallback();\n        } else {\n          if (_this.compiler) {\n            _this.compiler.hooks.forkTsCheckerWaiting.call(_this.tslint !== false);\n          }\n\n          if (!_this.silent && _this.logger) {\n            _this.logger.info(_this.tslint ? 'Type checking and linting in progress...' : 'Type checking in progress...');\n          }\n        }\n\n        _this.compilationDone = true;\n      });\n    } else {\n      // webpack 2 / 3\n      this.compiler.plugin('done', function () {\n        if (!_this.isWatching || !_this.async) {\n          return;\n        }\n\n        if (_this.checkDone) {\n          _this.doneCallback();\n        } else {\n          if (_this.compiler) {\n            _this.compiler.applyPlugins('fork-ts-checker-waiting', _this.tslint !== false);\n          }\n\n          if (!_this.silent && _this.logger) {\n            _this.logger.info(_this.tslint ? 'Type checking and linting in progress...' : 'Type checking in progress...');\n          }\n        }\n\n        _this.compilationDone = true;\n      });\n    }\n  };\n\n  ForkTsCheckerWebpackPlugin.prototype.spawnService = function () {\n    var _this = this;\n\n    this.service = childProcess.fork(path.resolve(__dirname, this.workersNumber > 1 ? './cluster.js' : './service.js'), [], {\n      execArgv: this.workersNumber > 1 ? [] : ['--max-old-space-size=' + this.memoryLimit],\n      env: Object.assign({}, process.env, {\n        TYPESCRIPT_PATH: this.typescriptPath,\n        TSCONFIG: this.tsconfigPath,\n        COMPILER_OPTIONS: JSON.stringify(this.compilerOptions),\n        TSLINT: this.tslintPath || '',\n        WATCH: this.isWatching ? this.watchPaths.join('|') : '',\n        WORK_DIVISION: Math.max(1, this.workersNumber),\n        MEMORY_LIMIT: this.memoryLimit,\n        CHECK_SYNTACTIC_ERRORS: this.checkSyntacticErrors,\n        VUE: this.vue\n      }),\n      stdio: ['inherit', 'inherit', 'inherit', 'ipc']\n    });\n\n    if ('hooks' in this.compiler) {\n      // webpack 4\n      this.compiler.hooks.forkTsCheckerServiceStart.call(this.tsconfigPath, this.tslintPath, this.watchPaths, this.workersNumber, this.memoryLimit);\n    } else {\n      // webpack 2 / 3\n      this.compiler.applyPlugins('fork-ts-checker-service-start', this.tsconfigPath, this.tslintPath, this.watchPaths, this.workersNumber, this.memoryLimit);\n    }\n\n    if (!this.silent && this.logger) {\n      this.logger.info('Starting type checking' + (this.tslint ? ' and linting' : '') + ' service...');\n      this.logger.info('Using ' + this.colors.bold(this.workersNumber === 1 ? '1 worker' : this.workersNumber + ' workers') + ' with ' + this.colors.bold(this.memoryLimit + 'MB') + ' memory limit');\n\n      if (this.watchPaths.length && this.isWatching) {\n        this.logger.info('Watching:' + (this.watchPaths.length > 1 ? '\\n' : ' ') + this.watchPaths.map(function (wpath) {\n          return _this.colors.grey(wpath);\n        }).join('\\n'));\n      }\n    }\n\n    this.service.on('message', function (message) {\n      return _this.handleServiceMessage(message);\n    });\n    this.service.on('exit', function (code, signal) {\n      return _this.handleServiceExit(code, signal);\n    });\n  };\n\n  ForkTsCheckerWebpackPlugin.prototype.killService = function () {\n    if (this.service) {\n      try {\n        if (this.cancellationToken) {\n          this.cancellationToken.cleanupCancellation();\n        }\n\n        this.service.kill();\n        this.service = undefined;\n      } catch (e) {\n        if (this.logger && !this.silent) {\n          this.logger.error(e);\n        }\n      }\n    }\n  };\n\n  ForkTsCheckerWebpackPlugin.prototype.handleServiceMessage = function (message) {\n    var _this = this;\n\n    if (this.cancellationToken) {\n      this.cancellationToken.cleanupCancellation(); // job is done - nothing to cancel\n\n      this.cancellationToken = undefined;\n    }\n\n    this.checkDone = true;\n    this.elapsed = process.hrtime(this.started);\n    this.diagnostics = message.diagnostics.map(NormalizedMessage_1.NormalizedMessage.createFromJSON);\n    this.lints = message.lints.map(NormalizedMessage_1.NormalizedMessage.createFromJSON);\n\n    if (this.ignoreDiagnostics.length) {\n      this.diagnostics = this.diagnostics.filter(function (diagnostic) {\n        return _this.ignoreDiagnostics.indexOf(parseInt(diagnostic.getCode(), 10)) === -1;\n      });\n    }\n\n    if (this.ignoreLints.length) {\n      this.lints = this.lints.filter(function (lint) {\n        return _this.ignoreLints.indexOf(lint.getCode()) === -1;\n      });\n    }\n\n    if (this.reportFiles.length) {\n      var reportFilesPredicate = function reportFilesPredicate(diagnostic) {\n        if (diagnostic.file) {\n          var relativeFileName = path.relative(_this.compiler.options.context, diagnostic.file);\n          var matchResult = micromatch([relativeFileName], _this.reportFiles);\n\n          if (matchResult.length === 0) {\n            return false;\n          }\n        }\n\n        return true;\n      };\n\n      this.diagnostics = this.diagnostics.filter(reportFilesPredicate);\n      this.lints = this.lints.filter(reportFilesPredicate);\n    }\n\n    if ('hooks' in this.compiler) {\n      // webpack 4\n      this.compiler.hooks.forkTsCheckerReceive.call(this.diagnostics, this.lints);\n    } else {\n      // webpack 2 / 3\n      this.compiler.applyPlugins('fork-ts-checker-receive', this.diagnostics, this.lints);\n    }\n\n    if (this.compilationDone) {\n      this.isWatching && this.async ? this.doneCallback() : this.emitCallback();\n    }\n  };\n\n  ForkTsCheckerWebpackPlugin.prototype.handleServiceExit = function (_code, signal) {\n    if (signal === 'SIGABRT') {\n      // probably out of memory :/\n      if (this.compiler) {\n        if ('hooks' in this.compiler) {\n          // webpack 4\n          this.compiler.hooks.forkTsCheckerServiceOutOfMemory.call();\n        } else {\n          // webpack 2 / 3\n          this.compiler.applyPlugins('fork-ts-checker-service-out-of-memory');\n        }\n      }\n\n      if (!this.silent && this.logger) {\n        this.logger.error(this.colors.red('Type checking and linting aborted - probably out of memory. ' + 'Check `memoryLimit` option in ForkTsCheckerWebpackPlugin configuration.'));\n      }\n    }\n  };\n\n  ForkTsCheckerWebpackPlugin.prototype.createEmitCallback = function (compilation, callback) {\n    return function emitCallback() {\n      var _this = this;\n\n      var elapsed = Math.round(this.elapsed[0] * 1e9 + this.elapsed[1]);\n\n      if ('hooks' in this.compiler) {\n        // webpack 4\n        this.compiler.hooks.forkTsCheckerEmit.call(this.diagnostics, this.lints, elapsed);\n      } else {\n        // webpack 2 / 3\n        this.compiler.applyPlugins('fork-ts-checker-emit', this.diagnostics, this.lints, elapsed);\n      }\n\n      this.diagnostics.concat(this.lints).forEach(function (message) {\n        // webpack message format\n        var formatted = {\n          rawMessage: message.getSeverity().toUpperCase() + ' ' + message.getFormattedCode() + ': ' + message.getContent(),\n          message: _this.formatter(message, _this.useColors),\n          location: {\n            line: message.getLine(),\n            character: message.getCharacter()\n          },\n          file: message.getFile()\n        };\n\n        if (message.isWarningSeverity()) {\n          compilation.warnings.push(formatted);\n        } else {\n          compilation.errors.push(formatted);\n        }\n      });\n      callback();\n    };\n  };\n\n  ForkTsCheckerWebpackPlugin.prototype.createNoopEmitCallback = function () {\n    // tslint:disable-next-line:no-empty\n    return function noopEmitCallback() {};\n  };\n\n  ForkTsCheckerWebpackPlugin.prototype.createDoneCallback = function () {\n    return function doneCallback() {\n      var _this = this;\n\n      var elapsed = Math.round(this.elapsed[0] * 1e9 + this.elapsed[1]);\n\n      if (this.compiler) {\n        if ('hooks' in this.compiler) {\n          // webpack 4\n          this.compiler.hooks.forkTsCheckerDone.call(this.diagnostics, this.lints, elapsed);\n        } else {\n          // webpack 2 / 3\n          this.compiler.applyPlugins('fork-ts-checker-done', this.diagnostics, this.lints, elapsed);\n        }\n      }\n\n      if (!this.silent && this.logger) {\n        if (this.diagnostics.length || this.lints.length) {\n          (this.lints || []).concat(this.diagnostics).forEach(function (message) {\n            var formattedMessage = _this.formatter(message, _this.useColors);\n\n            message.isWarningSeverity() ? _this.logger.warn(formattedMessage) : _this.logger.error(formattedMessage);\n          });\n        }\n\n        if (!this.diagnostics.length) {\n          this.logger.info(this.colors.green('No type errors found'));\n        }\n\n        if (this.tslint && !this.lints.length) {\n          this.logger.info(this.colors.green('No lint errors found'));\n        }\n\n        this.logger.info('Version: typescript ' + this.colors.bold(this.typescriptVersion) + (this.tslint ? ', tslint ' + this.colors.bold(this.tslintVersion) : ''));\n        this.logger.info('Time: ' + this.colors.bold(Math.round(elapsed / 1e6).toString()) + 'ms');\n      }\n    };\n  };\n\n  ForkTsCheckerWebpackPlugin.DEFAULT_MEMORY_LIMIT = 2048;\n  ForkTsCheckerWebpackPlugin.ONE_CPU = 1;\n  ForkTsCheckerWebpackPlugin.ALL_CPUS = os.cpus && os.cpus() ? os.cpus().length : 1;\n  ForkTsCheckerWebpackPlugin.ONE_CPU_FREE = Math.max(1, ForkTsCheckerWebpackPlugin.ALL_CPUS - 1);\n  ForkTsCheckerWebpackPlugin.TWO_CPUS_FREE = Math.max(1, ForkTsCheckerWebpackPlugin.ALL_CPUS - 2);\n  return ForkTsCheckerWebpackPlugin;\n}();\n\nmodule.exports = ForkTsCheckerWebpackPlugin;"},"sourceMaps":null,"error":null,"hash":"18902038918d80946817647751c30f08","cacheData":{"env":{}}}