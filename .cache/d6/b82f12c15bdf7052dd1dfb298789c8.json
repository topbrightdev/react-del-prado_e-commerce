{"id":"../node_modules/webpack-dev-middleware/lib/util.js","dependencies":[{"name":"/home/jarri/Desktop/lenovo2020/projects-web/eCommerce/template-store1/package.json","includedInParent":true,"mtime":1594655291184},{"name":"/home/jarri/Desktop/lenovo2020/projects-web/eCommerce/template-store1/node_modules/webpack-dev-middleware/package.json","includedInParent":true,"mtime":1594306881658},{"name":"path","loc":{"line":3,"column":21},"parent":"/home/jarri/Desktop/lenovo2020/projects-web/eCommerce/template-store1/node_modules/webpack-dev-middleware/lib/util.js","resolved":"/home/jarri/Desktop/lenovo2020/projects-web/eCommerce/template-store1/node_modules/path-browserify/index.js"},{"name":"url","loc":{"line":4,"column":26},"parent":"/home/jarri/Desktop/lenovo2020/projects-web/eCommerce/template-store1/node_modules/webpack-dev-middleware/lib/util.js","resolved":"/home/jarri/Desktop/lenovo2020/projects-web/eCommerce/template-store1/node_modules/url/url.js"},{"name":"querystring","loc":{"line":5,"column":28},"parent":"/home/jarri/Desktop/lenovo2020/projects-web/eCommerce/template-store1/node_modules/webpack-dev-middleware/lib/util.js","resolved":"/home/jarri/Desktop/lenovo2020/projects-web/eCommerce/template-store1/node_modules/querystring-es3/index.js"},{"name":"range-parser","loc":{"line":6,"column":27},"parent":"/home/jarri/Desktop/lenovo2020/projects-web/eCommerce/template-store1/node_modules/webpack-dev-middleware/lib/util.js","resolved":"/home/jarri/Desktop/lenovo2020/projects-web/eCommerce/template-store1/node_modules/range-parser/index.js"},{"name":"process","parent":"/home/jarri/Desktop/lenovo2020/projects-web/eCommerce/template-store1/node_modules/webpack-dev-middleware/lib/util.js","resolved":"/home/jarri/Desktop/lenovo2020/projects-web/eCommerce/template-store1/node_modules/process/browser.js"}],"generated":{"js":"var process = require(\"process\");\n'use strict';\n\nvar path = require('path');\n\nvar {\n  parse\n} = require('url');\n\nvar querystring = require('querystring');\n\nvar parseRange = require('range-parser');\n\nvar HASH_REGEXP = /[0-9a-f]{10,}/; // support for multi-compiler configuration\n// see: https://github.com/webpack/webpack-dev-server/issues/641\n\nfunction getPaths(publicPath, compiler, url) {\n  var compilers = compiler && compiler.compilers;\n\n  if (Array.isArray(compilers)) {\n    var compilerPublicPath; // the path portion of compilerPublicPath\n\n    var compilerPublicPathBase;\n\n    for (var i = 0; i < compilers.length; i++) {\n      compilerPublicPath = compilers[i].options && compilers[i].options.output && compilers[i].options.output.publicPath;\n\n      if (compilerPublicPath) {\n        if (compilerPublicPath.indexOf('/') === 0) {\n          compilerPublicPathBase = compilerPublicPath;\n        } else {\n          // handle the case where compilerPublicPath is a URL with hostname\n          compilerPublicPathBase = parse(compilerPublicPath).pathname;\n        } // check the url vs the path part of the compilerPublicPath\n\n\n        if (url.indexOf(compilerPublicPathBase) === 0) {\n          return {\n            publicPath: compilerPublicPath,\n            outputPath: compilers[i].outputPath\n          };\n        }\n      }\n    }\n  }\n\n  return {\n    publicPath,\n    outputPath: compiler.outputPath\n  };\n}\n\nfunction ready(context, fn, req) {\n  if (context.state) {\n    return fn(context.webpackStats);\n  }\n\n  context.log.info(\"wait until bundle finished: \".concat(req.url || fn.name));\n  context.callbacks.push(fn);\n}\n\nmodule.exports = {\n  getFilenameFromUrl(pubPath, compiler, url) {\n    var {\n      outputPath,\n      publicPath\n    } = getPaths(pubPath, compiler, url); // localPrefix is the folder our bundle should be in\n\n    var localPrefix = parse(publicPath || '/', false, true);\n    var urlObject = parse(url);\n    var filename; // publicPath has the hostname that is not the same as request url's, should fail\n\n    if (localPrefix.hostname !== null && urlObject.hostname !== null && localPrefix.hostname !== urlObject.hostname) {\n      return false;\n    } // publicPath is not in url, so it should fail\n\n\n    if (publicPath && localPrefix.hostname === urlObject.hostname && url.indexOf(publicPath) !== 0) {\n      return false;\n    } // strip localPrefix from the start of url\n\n\n    if (urlObject.pathname.indexOf(localPrefix.pathname) === 0) {\n      filename = urlObject.pathname.substr(localPrefix.pathname.length);\n    }\n\n    if (!urlObject.hostname && localPrefix.hostname && url.indexOf(localPrefix.path) !== 0) {\n      return false;\n    }\n\n    var uri = outputPath;\n    /* istanbul ignore if */\n\n    if (process.platform === 'win32') {\n      // Path Handling for Microsoft Windows\n      if (filename) {\n        uri = path.posix.join(outputPath || '', querystring.unescape(filename));\n\n        if (!path.win32.isAbsolute(uri)) {\n          uri = \"/\".concat(uri);\n        }\n      }\n\n      return uri;\n    } // Path Handling for all other operating systems\n\n\n    if (filename) {\n      uri = path.posix.join(outputPath || '', filename);\n\n      if (!path.posix.isAbsolute(uri)) {\n        uri = \"/\".concat(uri);\n      }\n    } // if no matches, use outputPath as filename\n\n\n    return querystring.unescape(uri);\n  },\n\n  handleRangeHeaders(content, req, res) {\n    // assumes express API. For other servers, need to add logic to access\n    // alternative header APIs\n    res.setHeader('Accept-Ranges', 'bytes');\n\n    if (req.headers.range) {\n      var ranges = parseRange(content.length, req.headers.range); // unsatisfiable\n\n      if (ranges === -1) {\n        res.setHeader('Content-Range', \"bytes */\".concat(content.length));\n        res.statusCode = 416;\n      } // valid (syntactically invalid/multiple ranges are treated as a\n      // regular response)\n\n\n      if (ranges !== -2 && ranges.length === 1) {\n        var {\n          length\n        } = content; // Content-Range\n\n        res.statusCode = 206;\n        res.setHeader('Content-Range', \"bytes \".concat(ranges[0].start, \"-\").concat(ranges[0].end, \"/\").concat(length));\n        content = content.slice(ranges[0].start, ranges[0].end + 1);\n      }\n    }\n\n    return content;\n  },\n\n  handleRequest(context, filename, processRequest, req) {\n    // in lazy mode, rebuild on bundle request\n    if (context.options.lazy && (!context.options.filename || context.options.filename.test(filename))) {\n      context.rebuild();\n    }\n\n    if (HASH_REGEXP.test(filename)) {\n      try {\n        if (context.fs.statSync(filename).isFile()) {\n          processRequest();\n          return;\n        }\n      } catch (e) {// eslint-disable-line\n      }\n    }\n\n    ready(context, processRequest, req);\n  },\n\n  noop: function () {},\n  ready\n};"},"sourceMaps":null,"error":null,"hash":"d91ea059cace61bf826f014a352c43cb","cacheData":{"env":{}}}