{"id":"../node_modules/http-proxy-middleware/node_modules/extglob/lib/utils.js","dependencies":[{"name":"/home/jarri/Desktop/lenovo2020/projects-web/eCommerce/template-store1/package.json","includedInParent":true,"mtime":1594655165833},{"name":"/home/jarri/Desktop/lenovo2020/projects-web/eCommerce/template-store1/node_modules/http-proxy-middleware/node_modules/extglob/package.json","includedInParent":true,"mtime":1594306880062},{"name":"regex-not","loc":{"line":3,"column":20},"parent":"/home/jarri/Desktop/lenovo2020/projects-web/eCommerce/template-store1/node_modules/http-proxy-middleware/node_modules/extglob/lib/utils.js","resolved":"/home/jarri/Desktop/lenovo2020/projects-web/eCommerce/template-store1/node_modules/regex-not/index.js"},{"name":"fragment-cache","loc":{"line":4,"column":20},"parent":"/home/jarri/Desktop/lenovo2020/projects-web/eCommerce/template-store1/node_modules/http-proxy-middleware/node_modules/extglob/lib/utils.js","resolved":"/home/jarri/Desktop/lenovo2020/projects-web/eCommerce/template-store1/node_modules/fragment-cache/index.js"}],"generated":{"js":"'use strict';\n\nvar regex = require('regex-not');\n\nvar Cache = require('fragment-cache');\n/**\n * Utils\n */\n\n\nvar utils = module.exports;\nvar cache = utils.cache = new Cache();\n/**\n * Cast `val` to an array\n * @return {Array}\n */\n\nutils.arrayify = function (val) {\n  if (!Array.isArray(val)) {\n    return [val];\n  }\n\n  return val;\n};\n/**\n * Memoize a generated regex or function\n */\n\n\nutils.memoize = function (type, pattern, options, fn) {\n  var key = utils.createKey(type + pattern, options);\n\n  if (cache.has(type, key)) {\n    return cache.get(type, key);\n  }\n\n  var val = fn(pattern, options);\n\n  if (options && options.cache === false) {\n    return val;\n  }\n\n  cache.set(type, key, val);\n  return val;\n};\n/**\n * Create the key to use for memoization. The key is generated\n * by iterating over the options and concatenating key-value pairs\n * to the pattern string.\n */\n\n\nutils.createKey = function (pattern, options) {\n  var key = pattern;\n\n  if (typeof options === 'undefined') {\n    return key;\n  }\n\n  for (var prop in options) {\n    key += ';' + prop + '=' + String(options[prop]);\n  }\n\n  return key;\n};\n/**\n * Create the regex to use for matching text\n */\n\n\nutils.createRegex = function (str) {\n  var opts = {\n    contains: true,\n    strictClose: false\n  };\n  return regex(str, opts);\n};"},"sourceMaps":null,"error":null,"hash":"b4da5b4511a38e2d10388e4137a9b687","cacheData":{"env":{}}}