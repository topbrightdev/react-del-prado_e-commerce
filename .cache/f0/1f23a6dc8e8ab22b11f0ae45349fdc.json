{"id":"../node_modules/autoprefixer/lib/prefixer.js","dependencies":[{"name":"/home/jarri/Desktop/lenovo2020/projects-web/eCommerce/template-store1/package.json","includedInParent":true,"mtime":1594655165833},{"name":"/home/jarri/Desktop/lenovo2020/projects-web/eCommerce/template-store1/node_modules/autoprefixer/package.json","includedInParent":true,"mtime":1594570878686},{"name":"./browsers","loc":{"line":3,"column":23},"parent":"/home/jarri/Desktop/lenovo2020/projects-web/eCommerce/template-store1/node_modules/autoprefixer/lib/prefixer.js","resolved":"/home/jarri/Desktop/lenovo2020/projects-web/eCommerce/template-store1/node_modules/autoprefixer/lib/browsers.js"},{"name":"./utils","loc":{"line":5,"column":20},"parent":"/home/jarri/Desktop/lenovo2020/projects-web/eCommerce/template-store1/node_modules/autoprefixer/lib/prefixer.js","resolved":"/home/jarri/Desktop/lenovo2020/projects-web/eCommerce/template-store1/node_modules/autoprefixer/lib/utils.js"},{"name":"postcss","loc":{"line":7,"column":21},"parent":"/home/jarri/Desktop/lenovo2020/projects-web/eCommerce/template-store1/node_modules/autoprefixer/lib/prefixer.js","resolved":"/home/jarri/Desktop/lenovo2020/projects-web/eCommerce/template-store1/node_modules/autoprefixer/node_modules/postcss/lib/postcss.js"}],"generated":{"js":"\"use strict\";\n\nvar Browsers = require('./browsers');\n\nvar utils = require('./utils');\n\nvar vendor = require('postcss').vendor;\n/**\n * Recursively clone objects\n */\n\n\nfunction _clone(obj, parent) {\n  var cloned = new obj.constructor();\n\n  var _arr = Object.keys(obj || {});\n\n  for (var _i = 0; _i < _arr.length; _i++) {\n    var i = _arr[_i];\n    var value = obj[i];\n\n    if (i === 'parent' && typeof value === 'object') {\n      if (parent) {\n        cloned[i] = parent;\n      }\n    } else if (i === 'source' || i === null) {\n      cloned[i] = value;\n    } else if (value instanceof Array) {\n      cloned[i] = value.map(function (x) {\n        return _clone(x, cloned);\n      });\n    } else if (i !== '_autoprefixerPrefix' && i !== '_autoprefixerValues') {\n      if (typeof value === 'object' && value !== null) {\n        value = _clone(value, cloned);\n      }\n\n      cloned[i] = value;\n    }\n  }\n\n  return cloned;\n}\n\nvar Prefixer = /*#__PURE__*/function () {\n  /**\n     * Add hack to selected names\n     */\n  Prefixer.hack = function hack(klass) {\n    var _this = this;\n\n    if (!this.hacks) {\n      this.hacks = {};\n    }\n\n    return klass.names.map(function (name) {\n      _this.hacks[name] = klass;\n      return _this.hacks[name];\n    });\n  };\n  /**\n     * Load hacks for some names\n     */\n\n\n  Prefixer.load = function load(name, prefixes, all) {\n    var Klass = this.hacks && this.hacks[name];\n\n    if (Klass) {\n      return new Klass(name, prefixes, all);\n    } else {\n      return new this(name, prefixes, all);\n    }\n  };\n  /**\n     * Clone node and clean autprefixer custom caches\n     */\n\n\n  Prefixer.clone = function clone(node, overrides) {\n    var cloned = _clone(node);\n\n    for (var name in overrides) {\n      cloned[name] = overrides[name];\n    }\n\n    return cloned;\n  };\n\n  function Prefixer(name, prefixes, all) {\n    this.prefixes = prefixes;\n    this.name = name;\n    this.all = all;\n  }\n  /**\n     * Find prefix in node parents\n     */\n\n\n  var _proto = Prefixer.prototype;\n\n  _proto.parentPrefix = function parentPrefix(node) {\n    var prefix;\n\n    if (typeof node._autoprefixerPrefix !== 'undefined') {\n      prefix = node._autoprefixerPrefix;\n    } else if (node.type === 'decl' && node.prop[0] === '-') {\n      prefix = vendor.prefix(node.prop);\n    } else if (node.type === 'root') {\n      prefix = false;\n    } else if (node.type === 'rule' && node.selector.indexOf(':-') !== -1 && /:(-\\w+-)/.test(node.selector)) {\n      prefix = node.selector.match(/:(-\\w+-)/)[1];\n    } else if (node.type === 'atrule' && node.name[0] === '-') {\n      prefix = vendor.prefix(node.name);\n    } else {\n      prefix = this.parentPrefix(node.parent);\n    }\n\n    if (Browsers.prefixes().indexOf(prefix) === -1) {\n      prefix = false;\n    }\n\n    node._autoprefixerPrefix = prefix;\n    return node._autoprefixerPrefix;\n  };\n  /**\n     * Clone node with prefixes\n     */\n\n\n  _proto.process = function process(node, result) {\n    if (!this.check(node)) {\n      return undefined;\n    }\n\n    var parent = this.parentPrefix(node);\n    var prefixes = this.prefixes.filter(function (prefix) {\n      return !parent || parent === utils.removeNote(prefix);\n    });\n    var added = [];\n\n    for (var _iterator = prefixes, _isArray = Array.isArray(_iterator), _i2 = 0, _iterator = _isArray ? _iterator : _iterator[Symbol.iterator]();;) {\n      var _ref;\n\n      if (_isArray) {\n        if (_i2 >= _iterator.length) break;\n        _ref = _iterator[_i2++];\n      } else {\n        _i2 = _iterator.next();\n        if (_i2.done) break;\n        _ref = _i2.value;\n      }\n\n      var prefix = _ref;\n\n      if (this.add(node, prefix, added.concat([prefix]), result)) {\n        added.push(prefix);\n      }\n    }\n\n    return added;\n  };\n  /**\n     * Shortcut for Prefixer.clone\n     */\n\n\n  _proto.clone = function clone(node, overrides) {\n    return Prefixer.clone(node, overrides);\n  };\n\n  return Prefixer;\n}();\n\nmodule.exports = Prefixer;"},"sourceMaps":null,"error":null,"hash":"6612b3e8414a9a5463bce418bfba6d1d","cacheData":{"env":{}}}