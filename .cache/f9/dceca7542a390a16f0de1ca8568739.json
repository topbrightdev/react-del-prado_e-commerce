{"id":"../node_modules/webpack/node_modules/webpack-sources/lib/applySourceMap.js","dependencies":[{"name":"/home/jarri/Desktop/lenovo2020/projects-web/eCommerce/template-store1/package.json","includedInParent":true,"mtime":1594655165833},{"name":"/home/jarri/Desktop/lenovo2020/projects-web/eCommerce/template-store1/node_modules/webpack/node_modules/webpack-sources/package.json","includedInParent":true,"mtime":1594570878394},{"name":"source-map","loc":{"line":9,"column":32},"parent":"/home/jarri/Desktop/lenovo2020/projects-web/eCommerce/template-store1/node_modules/webpack/node_modules/webpack-sources/lib/applySourceMap.js","resolved":"/home/jarri/Desktop/lenovo2020/projects-web/eCommerce/template-store1/node_modules/webpack/node_modules/source-map/source-map.js"}],"generated":{"js":"/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\n\"use strict\";\n\nvar SourceNode = require(\"source-map\").SourceNode;\nvar SourceMapConsumer = require(\"source-map\").SourceMapConsumer;\n\nvar applySourceMap = function(\n\tsourceNode,\n\tsourceMapConsumer,\n\tsourceFile,\n\tremoveGeneratedCodeForSourceFile\n) {\n\t// The following notations are used to name stuff:\n\t// Left <------------> Middle <-------------------> Right\n\t// Input arguments:\n\t//        sourceNode                                       - Code mapping from Left to Middle\n\t//                   sourceFile                            - Name of a Middle file\n\t//                              sourceMapConsumer          - Code mapping from Middle to Right\n\t// Variables:\n\t//           l2m                      m2r\n\t// Left <-----------------------------------------> Right\n\t// Variables:\n\t//                       l2r\n\n\tvar l2rResult = new SourceNode();\n\tvar l2rOutput = [];\n\n\tvar middleSourceContents = {};\n\n\tvar m2rMappingsByLine = {};\n\n\tvar rightSourceContentsSet = {};\n\tvar rightSourceContentsLines = {};\n\n\t// Store all mappings by generated line\n\tsourceMapConsumer.eachMapping(\n\t\tfunction(mapping) {\n\t\t\t(m2rMappingsByLine[mapping.generatedLine] =\n\t\t\t\tm2rMappingsByLine[mapping.generatedLine] || []).push(mapping);\n\t\t},\n\t\tnull,\n\t\tSourceMapConsumer.GENERATED_ORDER\n\t);\n\n\t// Store all source contents\n\tsourceNode.walkSourceContents(function(source, content) {\n\t\tmiddleSourceContents[\"$\" + source] = content;\n\t});\n\n\tvar middleSource = middleSourceContents[\"$\" + sourceFile];\n\tvar middleSourceLines = middleSource ? middleSource.split(\"\\n\") : undefined;\n\n\t// Walk all left to middle mappings\n\tsourceNode.walk(function(chunk, middleMapping) {\n\t\tvar source;\n\n\t\t// Find a mapping from middle to right\n\t\tif(\n\t\t\tmiddleMapping.source === sourceFile &&\n\t\t\tmiddleMapping.line &&\n\t\t\tm2rMappingsByLine[middleMapping.line]\n\t\t) {\n\t\t\tvar m2rBestFit;\n\t\t\tvar m2rMappings = m2rMappingsByLine[middleMapping.line];\n\t\t\t// Note: if this becomes a performance problem, use binary search\n\t\t\tfor(var i = 0; i < m2rMappings.length; i++) {\n\t\t\t\tif(m2rMappings[i].generatedColumn <= middleMapping.column) {\n\t\t\t\t\tm2rBestFit = m2rMappings[i];\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(m2rBestFit) {\n\t\t\t\tvar allowMiddleName = false;\n\t\t\t\tvar middleLine;\n\t\t\t\tvar rightSourceContent;\n\t\t\t\tvar rightSourceContentLines;\n\t\t\t\tvar rightSource = m2rBestFit.source;\n\t\t\t\t// Check if we have middle and right source for this mapping\n\t\t\t\t// Then we could have an \"identify\" mapping\n\t\t\t\tif(\n\t\t\t\t\tmiddleSourceLines &&\n\t\t\t\t\trightSource &&\n\t\t\t\t\t(middleLine = middleSourceLines[m2rBestFit.generatedLine - 1]) &&\n\t\t\t\t\t((rightSourceContentLines = rightSourceContentsLines[rightSource]) ||\n\t\t\t\t\t\t(rightSourceContent = sourceMapConsumer.sourceContentFor(\n\t\t\t\t\t\t\trightSource,\n\t\t\t\t\t\t\ttrue\n\t\t\t\t\t\t)))\n\t\t\t\t) {\n\t\t\t\t\tif(!rightSourceContentLines) {\n\t\t\t\t\t\trightSourceContentLines = rightSourceContentsLines[\n\t\t\t\t\t\t\trightSource\n\t\t\t\t\t\t] = rightSourceContent.split(\"\\n\");\n\t\t\t\t\t}\n\t\t\t\t\tvar rightLine = rightSourceContentLines[m2rBestFit.originalLine - 1];\n\t\t\t\t\tif(rightLine) {\n\t\t\t\t\t\tvar offset = middleMapping.column - m2rBestFit.generatedColumn;\n\t\t\t\t\t\tif(offset > 0) {\n\t\t\t\t\t\t\tvar middlePart = middleLine.slice(\n\t\t\t\t\t\t\t\tm2rBestFit.generatedColumn,\n\t\t\t\t\t\t\t\tmiddleMapping.column\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\tvar rightPart = rightLine.slice(\n\t\t\t\t\t\t\t\tm2rBestFit.originalColumn,\n\t\t\t\t\t\t\t\tm2rBestFit.originalColumn + offset\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\tif(middlePart === rightPart) {\n\t\t\t\t\t\t\t\t// When original and generated code is equal we assume we have an \"identity\" mapping\n\t\t\t\t\t\t\t\t// In this case we can offset the original position\n\t\t\t\t\t\t\t\tm2rBestFit = Object.assign({}, m2rBestFit, {\n\t\t\t\t\t\t\t\t\toriginalColumn: m2rBestFit.originalColumn + offset,\n\t\t\t\t\t\t\t\t\tgeneratedColumn: middleMapping.column\n\t\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(!m2rBestFit.name && middleMapping.name) {\n\t\t\t\t\t\t\tallowMiddleName =\n\t\t\t\t\t\t\t\trightLine.slice(\n\t\t\t\t\t\t\t\t\tm2rBestFit.originalColumn,\n\t\t\t\t\t\t\t\t\tm2rBestFit.originalColumn + middleMapping.name.length\n\t\t\t\t\t\t\t\t) === middleMapping.name;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// Construct a left to right node from the found middle to right mapping\n\t\t\t\tsource = m2rBestFit.source;\n\t\t\t\tl2rOutput.push(\n\t\t\t\t\tnew SourceNode(\n\t\t\t\t\t\tm2rBestFit.originalLine,\n\t\t\t\t\t\tm2rBestFit.originalColumn,\n\t\t\t\t\t\tsource,\n\t\t\t\t\t\tchunk,\n\t\t\t\t\t\tallowMiddleName ? middleMapping.name : m2rBestFit.name\n\t\t\t\t\t)\n\t\t\t\t);\n\n\t\t\t\t// Set the source contents once\n\t\t\t\tif(!(\"$\" + source in rightSourceContentsSet)) {\n\t\t\t\t\trightSourceContentsSet[\"$\" + source] = true;\n\t\t\t\t\tvar sourceContent = sourceMapConsumer.sourceContentFor(source, true);\n\t\t\t\t\tif(sourceContent) {\n\t\t\t\t\t\tl2rResult.setSourceContent(source, sourceContent);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\n\t\tif((removeGeneratedCodeForSourceFile && middleMapping.source === sourceFile) || !middleMapping.source) {\n\t\t\t// Construct a left to middle node with only generated code\n\t\t\t// Because user do not want mappings to middle sources\n\t\t\t// Or this chunk has no mapping\n\t\t\tl2rOutput.push(chunk);\n\t\t\treturn;\n\t\t}\n\n\t\t// Construct a left to middle node\n\t\tsource = middleMapping.source;\n\t\tl2rOutput.push(\n\t\t\tnew SourceNode(\n\t\t\t\tmiddleMapping.line,\n\t\t\t\tmiddleMapping.column,\n\t\t\t\tsource,\n\t\t\t\tchunk,\n\t\t\t\tmiddleMapping.name\n\t\t\t)\n\t\t);\n\t\tif(\"$\" + source in middleSourceContents) {\n\t\t\tif(!(\"$\" + source in rightSourceContentsSet)) {\n\t\t\t\tl2rResult.setSourceContent(source, middleSourceContents[\"$\" + source]);\n\t\t\t\tdelete middleSourceContents[\"$\" + source];\n\t\t\t}\n\t\t}\n\t});\n\n\t// Put output into the resulting SourceNode\n\tl2rResult.add(l2rOutput);\n\treturn l2rResult;\n};\n\nmodule.exports = applySourceMap;\n"},"sourceMaps":null,"error":null,"hash":"c2ddbbad3166d3e11a96ddc4cd1bf594","cacheData":{"env":{}}}